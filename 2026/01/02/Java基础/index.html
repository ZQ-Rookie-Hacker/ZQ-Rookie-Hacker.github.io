<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/zhuzhuxia-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/zhuzhuxia-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zq-rookie-hacker.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":"18px","offset":0},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"placeholder":"搜索文章...","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、Java虚拟机与平台特性1. JVM架构详解 类加载器子系统：  启动类加载器（Bootstrap）：加载rt.jar等核心库 扩展类加载器（Extension）：加载jre&#x2F;lib&#x2F;ext目录 应用类加载器（Application）：加载CLASSPATH路径 自定义类加载器：继承ClassLoader实现热部署   运行时数据区：   graph LR A[方法区] --&gt; B[类信息]">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://zq-rookie-hacker.github.io/2026/01/02/Java%E5%9F%BA%E7%A1%80/">
<meta property="og:site_name" content="ZQ-Rookie-Hacker&#39;s Blog">
<meta property="og:description" content="一、Java虚拟机与平台特性1. JVM架构详解 类加载器子系统：  启动类加载器（Bootstrap）：加载rt.jar等核心库 扩展类加载器（Extension）：加载jre&#x2F;lib&#x2F;ext目录 应用类加载器（Application）：加载CLASSPATH路径 自定义类加载器：继承ClassLoader实现热部署   运行时数据区：   graph LR A[方法区] --&gt; B[类信息]">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2026-01-02T12:14:23.670Z">
<meta property="article:modified_time" content="2026-01-04T02:36:26.185Z">
<meta property="article:author" content="ZQ-Rookie-Hacker">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zq-rookie-hacker.github.io/2026/01/02/Java%E5%9F%BA%E7%A1%80/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zq-rookie-hacker.github.io/2026/01/02/Java%E5%9F%BA%E7%A1%80/","path":"2026/01/02/Java基础/","title":"Java基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java基础 | ZQ-Rookie-Hacker's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"22F2XnoONZRtEbXvXO1SDcjS-gzGzoHsz","app_key":"bIFSRG6LeUO90VdfRBHUXNQs","interval":900,"minimum_time":10,"cache":true,"cache_expire":900,"betterPerformance":true,"id":"path"}</script>
  <script src="/js/third-party/statistics/lean-analytics.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZQ-Rookie-Hacker's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%B9%B3%E5%8F%B0%E7%89%B9%E6%80%A7"><span class="nav-text">一、Java虚拟机与平台特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JVM%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="nav-text">1. JVM架构详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="nav-text">2. 跨平台原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">二、基础语法与数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90"><span class="nav-text">1. 基本数据类型解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6"><span class="nav-text">2. 字符串处理深度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="nav-text">三、正则表达式深度解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">1. 正则表达式基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="nav-text">（1）字符匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%87%8F%E8%AF%8D%EF%BC%88%E6%8E%A7%E5%88%B6%E5%8C%B9%E9%85%8D%E6%AC%A1%E6%95%B0%EF%BC%89"><span class="nav-text">（2）量词（控制匹配次数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%BE%B9%E7%95%8C%E5%8C%B9%E9%85%8D"><span class="nav-text">（3）边界匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%88%86%E7%BB%84%E4%B8%8E%E6%8D%95%E8%8E%B7"><span class="nav-text">（4）分组与捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">（5）逻辑运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Java%E6%AD%A3%E5%88%99%E6%A0%B8%E5%BF%83%E7%B1%BB%EF%BC%88Pattern%E4%B8%8EMatcher%EF%BC%89"><span class="nav-text">2. Java正则核心类（Pattern与Matcher）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Pattern%E7%B1%BB%EF%BC%88%E7%BC%96%E8%AF%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89"><span class="nav-text">（1）Pattern类（编译正则表达式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Matcher%E7%B1%BB%EF%BC%88%E6%89%A7%E8%A1%8C%E5%8C%B9%E9%85%8D%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="nav-text">（2）Matcher类（执行匹配操作）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="nav-text">3. 常用场景示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81"><span class="nav-text">（1）数据验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%96%87%E6%9C%AC%E6%8F%90%E5%8F%96"><span class="nav-text">（2）文本提取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2"><span class="nav-text">（3）文本替换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-text">四、数组与集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-text">1. 数组底层实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="nav-text">2. 集合框架深度解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-List%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">(1) List实现类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Set%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">(2) Set实现类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Map%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">(3) Map实现类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93"><span class="nav-text">(5)总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="nav-text">五、面向对象深度解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="nav-text">1. 继承与多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">2. 抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8E%A5%E5%8F%A3"><span class="nav-text">3. 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%81%94%E7%B3%BB%E6%80%BB%E7%BB%93"><span class="nav-text">4. 抽象类与接口的联系总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%A7%A3%E6%9E%90"><span class="nav-text">六、异常处理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">1. 异常体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">2. 异常处理最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E8%A7%A3%E6%9E%90"><span class="nav-text">七、内部类解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9B%9B%E7%A7%8D%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="nav-text">1. 四种内部类详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E6%96%87%E4%BB%B6I-O%E4%B8%8ENIO-2"><span class="nav-text">八、文件I&#x2F;O与NIO.2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BC%A0%E7%BB%9FIO%E6%B5%81%E4%BD%93%E7%B3%BB"><span class="nav-text">1. 传统IO流体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-NIO-2%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-text">2. NIO.2核心特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="nav-text">九、泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E5%8E%9F%E7%90%86"><span class="nav-text">类型擦除原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="nav-text">绕过类型擦除获取泛型类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-java-8"><span class="nav-text">十、Lambda表达式(java 8+)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="nav-text">Lambda 表达式通用语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E7%AE%80%E5%8C%96%E8%A7%84%E5%88%99"><span class="nav-text">语法简化规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%B8%8F%E2%83%A3-%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%88%E5%B8%A6%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="nav-text">1️⃣ 完整版（带类型和代码块）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%B8%8F%E2%83%A3-%E7%9C%81%E7%95%A5%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%88%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%96%AD%EF%BC%89"><span class="nav-text">2️⃣ 省略参数类型（编译器自动推断）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%B8%8F%E2%83%A3-%E5%8D%95%E5%8F%82%E6%95%B0%E7%9C%81%E7%95%A5%E6%8B%AC%E5%8F%B7"><span class="nav-text">3️⃣ 单参数省略括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%B8%8F%E2%83%A3-%E5%8D%95%E8%A1%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9C%81%E7%95%A5-return-%E5%92%8C"><span class="nav-text">4️⃣ 单行表达式省略 return 和 {}</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%EF%B8%8F%E2%83%A3-%E6%97%A0%E5%8F%82%E6%95%B0%E6%97%B6%E7%94%A8%E7%A9%BA%E6%8B%AC%E5%8F%B7"><span class="nav-text">5️⃣ 无参数时用空括号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="nav-text">经典场景示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-1%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="nav-text">✅ 场景 1：函数式接口实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-2%EF%BC%9AStream-API-%E8%BF%87%E6%BB%A4"><span class="nav-text">✅ 场景 2：Stream API 过滤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-3%EF%BC%9A%E5%A4%9A%E5%8F%82%E6%95%B0-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">✅ 场景 3：多参数 + 代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-4%EF%BC%9A%E6%97%A0%E5%8F%82%E6%95%B0%EF%BC%88%E5%A6%82-Runnable%EF%BC%89"><span class="nav-text">✅ 场景 4：无参数（如 Runnable）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">关键注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-text">Lambda语法总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Optional%E7%B1%BB%E4%BD%BF%E7%94%A8"><span class="nav-text">十一、Optional类使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional-%E7%B1%BB%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%BD%BB%E5%BA%95%E5%91%8A%E5%88%AB-NPE%EF%BC%88%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%EF%BC%89"><span class="nav-text">Optional 类深度解析：彻底告别 NPE（空指针异常）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Optional%EF%BC%9F"><span class="nav-text">为什么需要 Optional？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%A9%BA%E5%80%BC%E5%A4%84%E7%90%86%E7%9A%84%E7%97%9B%E7%82%B9"><span class="nav-text">传统空值处理的痛点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Optional-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">Optional 的解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-text">Optional 核心方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%B8%8F%E2%83%A3-%E5%88%9B%E5%BB%BA-Optional-%E5%AE%9E%E4%BE%8B"><span class="nav-text">1️⃣ 创建 Optional 实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%B8%8F%E2%83%A3-%E5%AE%89%E5%85%A8%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="nav-text">2️⃣ 安全获取值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%B8%8F%E2%83%A3-%E8%BD%AC%E6%8D%A2%E5%80%BC%EF%BC%88%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%EF%BC%89"><span class="nav-text">3️⃣ 转换值（避免嵌套）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%B8%8F%E2%83%A3-%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%EF%BC%88%E6%97%A0%E5%80%BC-%E6%9C%89%E5%80%BC%E6%97%B6%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="nav-text">4️⃣ 条件处理（无值&#x2F;有值时操作）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F-vs-Optional"><span class="nav-text">传统 vs Optional</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF-1%EF%BC%9A%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1%E5%8F%96%E5%80%BC"><span class="nav-text">场景 1：嵌套对象取值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF-2%EF%BC%9A%E4%BB%8E-Map-%E4%B8%AD%E5%AE%89%E5%85%A8%E5%8F%96%E5%80%BC"><span class="nav-text">场景 2：从 Map 中安全取值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF-3%EF%BC%9A%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%EF%BC%88%E5%8F%AF%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%89"><span class="nav-text">场景 3：处理数据库查询结果（可能为空）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional-%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-text">Optional 使用规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BE%8B"><span class="nav-text">使用事例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">正确使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">链式调用示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8"><span class="nav-text">避免过度使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81Java-8-%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="nav-text">十二、Java 8+ 新特性详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API%EF%BC%88java-time%EF%BC%89"><span class="nav-text">1. 日期时间API（java.time）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-text">2. 并发工具类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%85%B3%E9%94%AE%E7%82%B9"><span class="nav-text">十三、JVM性能调优关键点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="nav-text">1. 内存参数配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD"><span class="nav-text">2. 常见内存问题诊断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">十四、设计模式的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%EF%BC%89"><span class="nav-text">1. 单例模式（双重检查锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%EF%BC%89"><span class="nav-text">2. 工厂模式（简单工厂）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Java%E5%86%85%E7%BD%AE%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="nav-text">3. 观察者模式（Java内置实现）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="nav-text">十五、反射机制深度解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%8D%E5%B0%84%E6%A0%B8%E5%BF%83API"><span class="nav-text">1. 反射核心API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2. 反射应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%8D%E5%B0%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-text">3. 反射性能优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%85%AD%E3%80%81JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89"><span class="nav-text">十六、JVM内存模型（JMM）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="nav-text">1. 主内存与工作内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%85%B3%E9%94%AE%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-text">2. 关键内存屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86"><span class="nav-text">3. volatile关键字原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%83%E3%80%81Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83"><span class="nav-text">十七、Java并发编程核心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">1. synchronized底层原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Lock%E6%8E%A5%E5%8F%A3%E4%B8%8EAQS"><span class="nav-text">2. Lock接口与AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="nav-text">3. 并发工具类详解</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZQ-Rookie-Hacker"
      src="/images/zhuzhuxia.jpg">
  <p class="site-author-name" itemprop="name">ZQ-Rookie-Hacker</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ZQ-Rookie-Hacker" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZQ-Rookie-Hacker" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zq-rookie-hacker.github.io/2026/01/02/Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zhuzhuxia.jpg">
      <meta itemprop="name" content="ZQ-Rookie-Hacker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZQ-Rookie-Hacker's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java基础 | ZQ-Rookie-Hacker's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2026-01-02 20:14:23" itemprop="dateCreated datePublished" datetime="2026-01-02T20:14:23+08:00">2026-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-04 10:36:26" itemprop="dateModified" datetime="2026-01-04T10:36:26+08:00">2026-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span id="/2026/01/02/Java%E5%9F%BA%E7%A1%80/" class="post-meta-item leancloud_visitors" data-flag-title="Java基础" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>41 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="一、Java虚拟机与平台特性"><a href="#一、Java虚拟机与平台特性" class="headerlink" title="一、Java虚拟机与平台特性"></a>一、Java虚拟机与平台特性</h2><h3 id="1-JVM架构详解"><a href="#1-JVM架构详解" class="headerlink" title="1. JVM架构详解"></a>1. JVM架构详解</h3><ul>
<li><p><strong>类加载器子系统</strong>：</p>
<ul>
<li>启动类加载器（Bootstrap）：加载<code>rt.jar</code>等核心库</li>
<li>扩展类加载器（Extension）：加载<code>jre/lib/ext</code>目录</li>
<li>应用类加载器（Application）：加载<code>CLASSPATH</code>路径</li>
<li>自定义类加载器：继承<code>ClassLoader</code>实现热部署</li>
</ul>
</li>
<li><p><strong>运行时数据区</strong>：</p>
<pre class="mermaid">  graph LR
A[方法区] --> B[类信息]
A --> C[常量池]
A --> D[静态变量]
E[堆] --> F[对象实例]
E --> G[数组]
H[栈] --> I[局部变量]
H --> J[操作数栈]
H --> K[帧数据]
L[程序计数器] --> M[当前字节码指令]
N[本地方法栈] --> O[JNI调用]</pre>
</li>
<li><p><strong>垃圾回收机制</strong>：</p>
<ul>
<li><strong>分代收集</strong>：新生代（Eden+S0+S1）和老年代</li>
<li><strong>GC算法</strong>：<ul>
<li>标记-清除：产生内存碎片</li>
<li>复制算法：适用于新生代（90%对象存活率低）</li>
<li>标记-整理：适用于老年代</li>
</ul>
</li>
<li><strong>常见GC器</strong>：<ul>
<li>Serial：单线程，适合客户端应用</li>
<li>Parallel：多线程吞吐量优先</li>
<li>CMS：低延迟，但会产生碎片</li>
<li>G1：分区收集，预测停顿时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-跨平台原理"><a href="#2-跨平台原理" class="headerlink" title="2. 跨平台原理"></a>2. 跨平台原理</h3><ul>
<li><strong>字节码文件</strong>（<code>.class</code>）：<ul>
<li>由Java编译器生成，与操作系统无关</li>
<li>包含：常量池、字段表、方法表、属性表</li>
</ul>
</li>
<li><strong>JVM执行过程</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译后字节码（<code>javap -c Test.class</code>）：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  Code:</span><br><span class="line">     0: getstatic     #2  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">     3: ldc           #3  // String Hello</span><br><span class="line">     5: invokevirtual #4  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">     8: return</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二、基础语法与数据类型"><a href="#二、基础语法与数据类型" class="headerlink" title="二、基础语法与数据类型"></a>二、基础语法与数据类型</h2><h3 id="1-基本数据类型解析"><a href="#1-基本数据类型解析" class="headerlink" title="1. 基本数据类型解析"></a>1. 基本数据类型解析</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类</th>
<th>大小</th>
<th>默认值</th>
<th>取值范围</th>
<th>特殊说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
<td>1字节</td>
<td>0</td>
<td>-128~127</td>
<td>适合存储小整数</td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
<td>2字节</td>
<td>0</td>
<td>-32768~32767</td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
<td>4字节</td>
<td>0</td>
<td>-2^31~2^31-1</td>
<td>最常用整型</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
<td>8字节</td>
<td>0L</td>
<td>-2^63~2^63-1</td>
<td>后缀<code>L</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Float</code></td>
<td>4字节</td>
<td>0.0f</td>
<td>±3.40282347E+38F</td>
<td>后缀<code>f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
<td>8字节</td>
<td>0.0d</td>
<td>±1.79769313486231570E+308</td>
<td>默认浮点类型</td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Character</code></td>
<td>2字节</td>
<td>‘\u0000’</td>
<td>0~65535</td>
<td>Unicode字符</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
<td>1位</td>
<td>false</td>
<td>true&#x2F;false</td>
<td>无具体大小</td>
</tr>
</tbody></table>
<p>关键说明</p>
<ol>
<li>包装类均为<strong>引用类型</strong>，首字母大写（两个特殊情况：<code>int</code> 对应 <code>Integer</code>、<code>char</code> 对应 <code>Character</code>，其余基本类型直接首字母大写即可）</li>
<li>包装类主要用于需要使用对象的场景（如集合框架、反射等），可实现基本类型与包装类的自动装箱&#x2F;拆箱</li>
</ol>
<ul>
<li><p><strong>自动类型转换规则</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> a; <span class="comment">// 自动提升：int → double</span></span><br><span class="line"><span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">int</span>)c; <span class="comment">// 显式转换，可能丢失精度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>装箱拆箱细节</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱：</span></span><br><span class="line">	将基本类型（如 <span class="type">int</span>）自动转换为包装类（如 Integer）。</span><br><span class="line">    编译后等价于：<span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//自动拆箱：</span></span><br><span class="line">    将包装类（如 Integer）自动转换为基本类型（如 <span class="type">int</span>）。</span><br><span class="line">    编译后等价于：<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x.intValue();</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x; <span class="comment">// 自动拆箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer缓存机制（-128~127）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true（引用相同）</span></span><br><span class="line"><span class="comment">//Java 为 Integer 在 -128 ~ 127 范围内创建了缓存对象（通过 IntegerCache 实现）。</span></span><br><span class="line"><span class="comment">//当通过 Integer.valueOf() 创建该范围内的值时，直接复用缓存对象，因此 a 和 b 指向同一个对象，== 比较返回true</span></span><br><span class="line">    </span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d); <span class="comment">// false（超出缓存范围） 所以缓存范围要记住！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存在的意义：</span></span><br><span class="line"><span class="number">1.</span>让基本类型“对象化”</span><br><span class="line">    Java 的泛型、集合框架、反射、注解等机制只能操作对象（引用类型），不能操作基本类型。包装类（如 Integer）将基本类型“封装”为对象，解决了这一矛盾。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>支持 <span class="literal">null</span> 值</span><br><span class="line">    基本类型（如 <span class="type">int</span>）必须有默认值（<span class="type">int</span> 默认是 <span class="number">0</span>），无法表示“无值”状态。</span><br><span class="line">    包装类可以为 <span class="literal">null</span>，适用于需要“可选值”的场景</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 合法：表示年龄未知</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 不合法：0 可能被误解为有效值</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>提供丰富的实用方法</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 字符串转数字</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">binary</span> <span class="operator">=</span> Integer.toBinaryString(<span class="number">10</span>); <span class="comment">// 转二进制字符串	</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.max(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 比较大小</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-字符串处理深度"><a href="#2-字符串处理深度" class="headerlink" title="2. 字符串处理深度"></a>2. 字符串处理深度</h3><ul>
<li><p><strong>String不可变性原理</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String 对象一旦创建，其内容无法修改</span><br><span class="line">效率问题：如果直接用 + 拼接多个字符串（如 a + b + c），每次操作都会创建新的 String 对象，导致大量临时对象和内存浪费。</span><br><span class="line"></span><br><span class="line">编译器的优化机制:</span><br><span class="line">	当代码中出现字符串拼接（+）时，Java编译器会自动将其转换为 StringBuilder 的链式调用</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s = s + <span class="string">&quot; World&quot;</span>; <span class="comment">// 实际创建了新对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层：new StringBuilder(&quot;Hello&quot;).append(&quot; World&quot;).toString()</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s)</span><br><span class="line">    将当前 s 的值（<span class="string">&quot;Hello&quot;</span>）作为初始内容传入 StringBuilder 的构造函数。</span><br><span class="line">    此时 StringBuilder 内部会复制 <span class="string">&quot;Hello&quot;</span> 的字符数组（非引用传递）。</span><br><span class="line"><span class="number">2.</span> .append(<span class="string">&quot; World&quot;</span>)</span><br><span class="line">    将 <span class="string">&quot; World&quot;</span> 追加到 StringBuilder 的内部缓冲区。</span><br><span class="line">    内部通过 <span class="type">char</span>[] 扩容和复制实现，避免频繁创建新对象。</span><br><span class="line"><span class="number">3.</span> .toString()</span><br><span class="line">    将 StringBuilder 的内容转换为一个新的 String 对象（<span class="string">&quot;Hello World&quot;</span>）。</span><br><span class="line">    这个新对象被赋值给 s，而原来的 <span class="string">&quot;Hello&quot;</span> 对象（若无其他引用）将被垃圾回收。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串常量池</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 字面量-&gt;直接放入常量池(若不存在)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 创建新对象，不在常量池，属于堆</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 字面量-&gt;引用常量池中的对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>String常用方法详解</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 内容比较（区分大小写）</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.equals(<span class="string">&quot;hello&quot;</span>); <span class="comment">// false（默认是严格对比）</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.equalsIgnoreCase(<span class="string">&quot;hello&quot;</span>); <span class="comment">// true（不区分大小写）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 字符串分割: split()函数的参数是正则表达式</span></span><br><span class="line"><span class="string">&quot;a,b,c&quot;</span>.split(<span class="string">&quot;,&quot;</span>); <span class="comment">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br><span class="line"><span class="string">&quot;a..b&quot;</span>.split(<span class="string">&quot;\\.\\.&quot;</span>); <span class="comment">// [&quot;a&quot;,&quot;b&quot;]（转义点号）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 字符串反转</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>).reverse().toString(); <span class="comment">// &quot;cba&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. intern()方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>).intern(); <span class="comment">// 返回常量池中的引用</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>) 的创建过程：</span><br><span class="line">	字面量 <span class="string">&quot;abc&quot;</span>：类加载时，<span class="string">&quot;abc&quot;</span> 会被自动放入字符串常量池（如果不存在）。</span><br><span class="line"><span class="number">2.</span><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>)：</span><br><span class="line">	强制在堆内存中创建新对象，内容为 <span class="string">&quot;abc&quot;</span>。该对象与常量池中的 <span class="string">&quot;abc&quot;</span> 是两个独立对象！此时堆中有一个新对象，常量池中有一个 <span class="string">&quot;abc&quot;</span>。</span><br><span class="line"><span class="number">3.</span>调用 .intern() 的过程：</span><br><span class="line">	JVM 检查常量池中是否已有内容相同的字符串（<span class="string">&quot;abc&quot;</span> 已存在），则直接返回常量池中的引用（不再创建新对象）。</span><br><span class="line"><span class="number">4.</span>s 被赋值为常量池中 <span class="string">&quot;abc&quot;</span> 的引用。</span><br><span class="line"> </span><br><span class="line">intern() 作用的关键总结：</span><br><span class="line">	如果常量池中已有该字符串，则返回池中的引用；</span><br><span class="line">	如果不存在，则将当前字符串放入池中，再返回池中的引用。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>StringBuilder vs StringBuffer</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>StringBuilder</th>
<th>StringBuffer</th>
</tr>
</thead>
<tbody><tr>
<td>线程安全</td>
<td>❌ 不安全</td>
<td>✅ 安全（synchronized）</td>
</tr>
<tr>
<td>性能</td>
<td>⚡️ 更快</td>
<td>⏳ 较慢</td>
</tr>
<tr>
<td>使用场景</td>
<td>单线程环境</td>
<td>多线程环境</td>
</tr>
</tbody></table>
</li>
<li><blockquote>
<p>用法完全一致！两者的 API 完全相同（方法名、参数、返回值、行为逻辑都一致），区别仅在于 线程安全性和性能。</p>
</blockquote>
</li>
</ul>
<h2 id="三、正则表达式深度解析"><a href="#三、正则表达式深度解析" class="headerlink" title="三、正则表达式深度解析"></a>三、正则表达式深度解析</h2><p>正则表达式（Regular Expression）是处理字符串的强大工具，用于匹配、查找、替换符合特定规则的文本。Java中通过<code>java.util.regex</code>包提供正则支持，核心类为<code>Pattern</code>（编译正则表达式）和<code>Matcher</code>（执行匹配操作）。</p>
<h3 id="1-正则表达式基本语法"><a href="#1-正则表达式基本语法" class="headerlink" title="1. 正则表达式基本语法"></a>1. 正则表达式基本语法</h3><h4 id="（1）字符匹配"><a href="#（1）字符匹配" class="headerlink" title="（1）字符匹配"></a>（1）字符匹配</h4><table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>普通字符</td>
<td>匹配自身</td>
<td><code>abc</code> 匹配 “abc”</td>
</tr>
<tr>
<td><code>.</code></td>
<td>匹配任意单个字符（除换行符）</td>
<td><code>a.c</code> 匹配 “abc”、”a1c”</td>
</tr>
<tr>
<td><code>[abc]</code></td>
<td>匹配括号内任意一个字符</td>
<td><code>[abc]</code> 匹配 “a”、”b”、”c”</td>
</tr>
<tr>
<td><code>[^abc]</code></td>
<td>匹配不在括号内的任意字符</td>
<td><code>[^abc]</code> 匹配 “d”、”1”</td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td>匹配指定范围的字符</td>
<td><code>[0-9a-zA-Z]</code> 匹配数字或字母</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>等价于 <code>[0-9]</code>（数字）</td>
<td><code>\d{3}</code> 匹配 “123”</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>等价于 <code>[^0-9]</code>（非数字）</td>
<td><code>\D</code> 匹配 “a”、”!”</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>等价于 <code>[a-zA-Z0-9_]</code>（单词字符）</td>
<td><code>\w+</code> 匹配 “user123”</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>等价于 <code>[^a-zA-Z0-9_]</code>（非单词字符）</td>
<td><code>\W</code> 匹配 “@”、”#”</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配空白字符（空格、制表符等）</td>
<td><code>a\sb</code> 匹配 “a b”、”a\tb”</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配非空白字符</td>
<td><code>a\Sb</code> 匹配 “a1b”、”a@b”</td>
</tr>
</tbody></table>
<h4 id="（2）量词（控制匹配次数）"><a href="#（2）量词（控制匹配次数）" class="headerlink" title="（2）量词（控制匹配次数）"></a>（2）量词（控制匹配次数）</h4><table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配前一个元素0次或多次（贪婪模式）</td>
<td><code>a*</code> 匹配 “”、”a”、”aa”</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前一个元素1次或多次（贪婪模式）</td>
<td><code>a+</code> 匹配 “a”、”aa”</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前一个元素0次或1次（贪婪模式）</td>
<td><code>a?</code> 匹配 “”、”a”</td>
</tr>
<tr>
<td><code>{n}</code></td>
<td>匹配前一个元素恰好n次</td>
<td><code>a{3}</code> 匹配 “aaa”</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>匹配前一个元素至少n次</td>
<td><code>a{2,}</code> 匹配 “aa”、”aaa”</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>匹配前一个元素n到m次</td>
<td><code>a{1,3}</code> 匹配 “a”、”aa”、”aaa”</td>
</tr>
<tr>
<td><code>*?</code>&#x2F;<code>+?</code>&#x2F;<code>??</code></td>
<td>非贪婪模式（尽可能少匹配）</td>
<td><code>&quot;a.*?b&quot;</code> 匹配 “aab” 中的 “aab”（而非贪婪的 “aab…b”）</td>
</tr>
</tbody></table>
<h4 id="（3）边界匹配"><a href="#（3）边界匹配" class="headerlink" title="（3）边界匹配"></a>（3）边界匹配</h4><table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>匹配字符串开始位置</td>
<td><code>^abc</code> 匹配 “abc123”（不匹配 “xabc”）</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配字符串结束位置</td>
<td><code>abc$</code> 匹配 “123abc”（不匹配 “abcx”）</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配单词边界（单词与非单词字符之间）</td>
<td><code>\bcat\b</code> 匹配 “cat”（不匹配 “category” 中的 “cat”）</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>匹配非单词边界</td>
<td><code>\Bcat\B</code> 匹配 “category” 中的 “cat”</td>
</tr>
</tbody></table>
<h4 id="（4）分组与捕获"><a href="#（4）分组与捕获" class="headerlink" title="（4）分组与捕获"></a>（4）分组与捕获</h4><table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>(pattern)</code></td>
<td>分组，将pattern视为一个整体，可捕获匹配结果</td>
<td><code>(ab)+</code> 匹配 “abab”</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>引用第n个分组的匹配结果（n为1-9）</td>
<td><code>(a)\1</code> 匹配 “aa”</td>
</tr>
<tr>
<td><code>(?:pattern)</code></td>
<td>非捕获分组（仅分组不捕获结果）</td>
<td><code>(?:ab)+</code> 匹配 “abab” 但不保存分组</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;pattern)</code></td>
<td>命名分组（通过名称引用）</td>
<td><code>(?&lt;id&gt;\d+)</code> 匹配数字并命名为”id”</td>
</tr>
</tbody></table>
<h4 id="（5）逻辑运算符"><a href="#（5）逻辑运算符" class="headerlink" title="（5）逻辑运算符"></a>（5）逻辑运算符</h4><table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&#96;</td>
<td>&#96;</td>
<td>逻辑或，匹配左边或右边的表达式</td>
</tr>
<tr>
<td><code>()</code></td>
<td>结合逻辑或</td>
<td>&#96;(ab</td>
</tr>
</tbody></table>
<h3 id="2-Java正则核心类（Pattern与Matcher）"><a href="#2-Java正则核心类（Pattern与Matcher）" class="headerlink" title="2. Java正则核心类（Pattern与Matcher）"></a>2. Java正则核心类（Pattern与Matcher）</h3><h4 id="（1）Pattern类（编译正则表达式）"><a href="#（1）Pattern类（编译正则表达式）" class="headerlink" title="（1）Pattern类（编译正则表达式）"></a>（1）Pattern类（编译正则表达式）</h4><ul>
<li>作用：预编译正则表达式为Pattern对象（线程安全，可复用）。</li>
<li>常用方法：<ul>
<li><code>Pattern.compile(String regex)</code>：编译正则表达式。</li>
<li><code>Pattern.matches(String regex, CharSequence input)</code>：快速匹配（等价于编译后直接调用<code>matches()</code>）。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatcherDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 先通过Pattern编译正则表达式（匹配3位数字）</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\d&#123;3&#125;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 传入输入字符串，通过Pattern的matcher()方法获取Matcher对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;abc123def456ghi78&quot;</span>;</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(input);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时matcher已绑定正则（\\d&#123;3&#125;）和输入字符串（abc123def456ghi78），可执行匹配操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="（2）Matcher类（执行匹配操作）"><a href="#（2）Matcher类（执行匹配操作）" class="headerlink" title="（2）Matcher类（执行匹配操作）"></a>（2）Matcher类（执行匹配操作）</h4><ul>
<li>作用：通过Pattern对象创建，用于对输入字符串执行匹配操作。</li>
<li>常用方法：<ul>
<li><code>matches()</code>：整个字符串是否完全匹配正则。</li>
<li><code>find()</code>：查找字符串中是否有匹配的子序列（可多次调用，每次找下一个）。</li>
<li><code>group()</code>：获取匹配的子序列（结合分组使用）。</li>
<li><code>start()</code>&#x2F;<code>end()</code>：获取匹配子序列的起始&#x2F;结束索引。</li>
<li><code>replaceAll(String replacement)</code>：替换所有匹配的子序列。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatcherMethodWithResultDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 预编译正则表达式：\\d+ 匹配1个及以上的数字（整数）</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line">        <span class="comment">// 待匹配的输入字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">inputStr</span> <span class="operator">=</span> <span class="string">&quot;abc123def456ghi7890&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 通过Pattern创建Matcher对象（绑定正则和输入字符串）</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(inputStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ========== 1. 演示 matches() 方法：全量匹配 ==========</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===== matches() 全量匹配 =====&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断整个输入字符串是否完全符合正则（\\d+ 要求全是数字，此处有字母，返回false）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFullMatch</span> <span class="operator">=</span> matcher.matches();</span><br><span class="line">        System.out.println(<span class="string">&quot;整个字符串是否完全匹配数字：&quot;</span> + isFullMatch); </span><br><span class="line">        <span class="comment">// 运行结果注释：输出 -&gt; 整个字符串是否完全匹配数字：false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：调用matches()后，Matcher的匹配状态会改变，如需后续操作，先重置</span></span><br><span class="line">        matcher.reset();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ========== 2. 演示 find() + group() + start()/end() 方法：查找+提取+获取位置 ==========</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== find() + group() + start()/end() 查找与提取 =====&quot;</span>);</span><br><span class="line">        <span class="comment">// while循环迭代：find() 每次调用查找下一个匹配的子串，无匹配时返回false</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            <span class="comment">// group()：获取当前匹配到的完整子串（等价于group(0)）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">matchContent</span> <span class="operator">=</span> matcher.group();</span><br><span class="line">            <span class="comment">// start()：获取匹配子串在输入字符串中的起始索引（从0开始，左闭）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> matcher.start();</span><br><span class="line">            <span class="comment">// end()：获取匹配子串在输入字符串中的结束索引（左闭右开，即最后一个字符的索引+1）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> matcher.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印结果</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;匹配到数字：%s，起始索引：%d，结束索引：%d，对应区间：[%d, %d)%n&quot;</span>,</span><br><span class="line">                    matchContent, startIndex, endIndex, startIndex, endIndex);</span><br><span class="line">            <span class="comment">// 循环内运行结果注释（依次输出）：</span></span><br><span class="line">            <span class="comment">// 匹配到数字：123，起始索引：3，结束索引：6，对应区间：[3, 6)</span></span><br><span class="line">            <span class="comment">// 匹配到数字：456，起始索引：9，结束索引：12，对应区间：[9, 12)</span></span><br><span class="line">            <span class="comment">// 匹配到数字：7890，起始索引：15，结束索引：19，对应区间：[15, 19)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ========== 3. 演示 group() 分组功能：正则中用()表示分组 ==========</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== group() 分组提取 =====&quot;</span>);</span><br><span class="line">        <span class="comment">// 重新编译带分组的正则：(\\d&#123;2&#125;)(\\d+) 表示把数字分为2组：前2位 + 剩余位数</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">groupPattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;2&#125;)(\\d+)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">groupMatcher</span> <span class="operator">=</span> groupPattern.matcher(inputStr);</span><br><span class="line">        <span class="comment">// 查找并提取分组内容</span></span><br><span class="line">        <span class="keyword">while</span> (groupMatcher.find()) &#123;</span><br><span class="line">            <span class="comment">// 1. 获取当前匹配项的完整子串（group(0) 固定对应完整匹配内容）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fullMatch</span> <span class="operator">=</span> groupMatcher.group(<span class="number">0</span>); </span><br><span class="line">            <span class="comment">// 匹配123时：fullMatch = &quot;123&quot;；匹配456时：fullMatch = &quot;456&quot;；匹配7890时：fullMatch = &quot;7890&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 获取第1个分组匹配的内容（对应第一个括号 (\\d&#123;2&#125;)：匹配2位数字）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">group1</span> <span class="operator">=</span> groupMatcher.group(<span class="number">1</span>);    </span><br><span class="line">            <span class="comment">// 匹配123时：group1 = &quot;12&quot;（前2位数字）；匹配456时：group1 = &quot;45&quot;；匹配7890时：group1 = &quot;78&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 获取第2个分组匹配的内容（对应第二个括号 (\\d+)：匹配1位及以上剩余数字）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">group2</span> <span class="operator">=</span> groupMatcher.group(<span class="number">2</span>);    </span><br><span class="line">            <span class="comment">// 匹配123时：group2 = &quot;3&quot;（剩余1位数字）；匹配456时：group2 = &quot;6&quot;；匹配7890时：group2 = &quot;90&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 格式化打印完整内容和分组内容</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;完整匹配：%s，分组1（前2位）：%s，分组2（剩余）：%s%n&quot;</span>,</span><br><span class="line">                    fullMatch, group1, group2);</span><br><span class="line">            <span class="comment">// 按格式拼接字符串并输出，对应示例中的三行打印结果</span></span><br><span class="line">            <span class="comment">// 循环内运行结果注释（依次输出）：</span></span><br><span class="line">            <span class="comment">// 完整匹配：123，分组1（前2位）：12，分组2（剩余）：3</span></span><br><span class="line">            <span class="comment">// 完整匹配：456，分组1（前2位）：45，分组2（剩余）：6</span></span><br><span class="line">            <span class="comment">// 完整匹配：7890，分组1（前2位）：78，分组2（剩余）：90</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ========== 4. 演示 replaceAll() 和 replaceFirst() 替换方法 ==========</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== replaceAll() + replaceFirst() 替换 =====&quot;</span>);</span><br><span class="line">        <span class="comment">// 重置Matcher状态，重新绑定输入字符串</span></span><br><span class="line">        matcher.reset();</span><br><span class="line">        <span class="comment">// replaceAll()：替换所有匹配的子串为指定内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">replaceAllResult</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;【数字】&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;替换所有数字后的结果：&quot;</span> + replaceAllResult);</span><br><span class="line">        <span class="comment">// 运行结果注释：输出 -&gt; 替换所有数字后的结果：abc【数字】def【数字】ghi【数字】</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次重置Matcher</span></span><br><span class="line">        matcher.reset();</span><br><span class="line">        <span class="comment">// replaceFirst()：只替换第一个匹配的子串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">replaceFirstResult</span> <span class="operator">=</span> matcher.replaceFirst(<span class="string">&quot;【首个数字】&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;只替换第一个数字后的结果：&quot;</span> + replaceFirstResult);</span><br><span class="line">        <span class="comment">// 运行结果注释：输出 -&gt; 只替换第一个数字后的结果：abc【首个数字】def456ghi7890</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-常用场景示例"><a href="#3-常用场景示例" class="headerlink" title="3. 常用场景示例"></a>3. 常用场景示例</h3><h4 id="（1）数据验证"><a href="#（1）数据验证" class="headerlink" title="（1）数据验证"></a>（1）数据验证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证邮箱（简单规则）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">emailRegex</span> <span class="operator">=</span> <span class="string">&quot;^[a-zA-Z0-9_]+@[a-zA-Z0-9]+(\\.[a-zA-Z0-9]+)+$&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmail</span> <span class="operator">=</span> <span class="string">&quot;user@example.com&quot;</span>.matches(emailRegex); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证手机号（中国大陆）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">phoneRegex</span> <span class="operator">=</span> <span class="string">&quot;^1[3-9]\\d&#123;9&#125;$&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isPhone</span> <span class="operator">=</span> <span class="string">&quot;13812345678&quot;</span>.matches(phoneRegex); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<h4 id="（2）文本提取"><a href="#（2）文本提取" class="headerlink" title="（2）文本提取"></a>（2）文本提取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从HTML中提取所有链接（&lt;a href=&quot;xxx&quot;&gt;）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&lt;a href=&#x27;https://a.com&#x27;&gt;链接1&lt;/a&gt;&lt;a href=&#x27;https://b.com&#x27;&gt;链接2&lt;/a&gt;&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">linkPattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;href=[&#x27;\&quot;](.*?)[&#x27;\&quot;]&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> linkPattern.matcher(html);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;链接：&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// 提取分组1的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 链接：https://a.com</span></span><br><span class="line"><span class="comment">// 链接：https://b.com</span></span><br></pre></td></tr></table></figure>


<h4 id="（3）文本替换"><a href="#（3）文本替换" class="headerlink" title="（3）文本替换"></a>（3）文本替换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换字符串中的所有数字为&quot;*&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;密码：123456，验证码：789&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replaced</span> <span class="operator">=</span> text.replaceAll(<span class="string">&quot;\\d&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(replaced); <span class="comment">// 输出：密码：******，验证码：***</span></span><br></pre></td></tr></table></figure>







<h2 id="四、数组与集合框架"><a href="#四、数组与集合框架" class="headerlink" title="四、数组与集合框架"></a>四、数组与集合框架</h2><h3 id="1-数组底层实现"><a href="#1-数组底层实现" class="headerlink" title="1. 数组底层实现"></a>1. 数组底层实现</h3><ul>
<li><strong>内存布局</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 内存结构：</span></span><br><span class="line"><span class="comment">// [arr对象头][length=3][0][0][0]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>多维数组</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 内存结构：</span></span><br><span class="line"><span class="comment">// [matrix对象头][length=2][array1][array2]</span></span><br><span class="line"><span class="comment">// array1: [length=3][0][0][0]</span></span><br><span class="line"><span class="comment">// array2: [length=3][0][0][0]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-集合框架深度解析"><a href="#2-集合框架深度解析" class="headerlink" title="2. 集合框架深度解析"></a>2. 集合框架深度解析</h3><h4 id="1-List实现类"><a href="#1-List实现类" class="headerlink" title="(1) List实现类"></a>(1) List实现类</h4><table>
<thead>
<tr>
<th>类型</th>
<th>底层结构</th>
<th>扩容机制</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ArrayList</strong></td>
<td>动态数组</td>
<td>1.5倍扩容</td>
<td>随机访问快<br>插入删除慢</td>
<td>频繁查询<br>较少修改</td>
</tr>
<tr>
<td><strong>LinkedList</strong></td>
<td>双向链表</td>
<td>无扩容</td>
<td>插入删除快<br>随机访问慢</td>
<td>频繁增删<br>较少查询</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>ArrayList扩容细节</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.8源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ArrayList常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListSimpleDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建ArrayList对象，存储字符串类型元素</span></span><br><span class="line">        List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 向集合中添加元素（尾部添加，简单高效）</span></span><br><span class="line">        arrayList.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;Go&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始ArrayList：&quot;</span> + arrayList);</span><br><span class="line">        <span class="comment">// 运行结果：初始ArrayList：[Java, Python, C++, Go]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 核心优势：随机访问（通过索引快速获取元素，对应表格中“随机访问快”）</span></span><br><span class="line">        <span class="comment">// 索引从0开始，直接获取第2个元素（Python）、第3个元素（C++）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element1</span> <span class="operator">=</span> arrayList.get(<span class="number">1</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">element2</span> <span class="operator">=</span> arrayList.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;索引1的元素：&quot;</span> + element1 + <span class="string">&quot;，索引2的元素：&quot;</span> + element2);</span><br><span class="line">        <span class="comment">// 运行结果：索引1的元素：Python，索引2的元素：C++</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 修改元素（通过索引快速修改）</span></span><br><span class="line">        arrayList.set(<span class="number">3</span>, <span class="string">&quot;Rust&quot;</span>); <span class="comment">// 将索引3的元素（Go）改为Rust</span></span><br><span class="line">        System.out.println(<span class="string">&quot;修改后ArrayList：&quot;</span> + arrayList);</span><br><span class="line">        <span class="comment">// 运行结果：修改后ArrayList：[Java, Python, C++, Rust]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 删除元素（尾部删除高效，中间删除效率低，对应表格“插入删除慢”）</span></span><br><span class="line">        arrayList.remove(<span class="number">2</span>); <span class="comment">// 删除索引2的元素（C++）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除索引2元素后：&quot;</span> + arrayList);</span><br><span class="line">        <span class="comment">// 运行结果：删除索引2元素后：[Java, Python, Rust]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 遍历集合（普通for循环，利用索引快速遍历，适配ArrayList特性）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;普通for循环遍历（适配ArrayList随机访问特性）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;索引&quot;</span> + i + <span class="string">&quot;：&quot;</span> + arrayList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运行结果：</span></span><br><span class="line">        <span class="comment">// 索引0：Java</span></span><br><span class="line">        <span class="comment">// 索引1：Python</span></span><br><span class="line">        <span class="comment">// 索引2：Rust</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LinkedList常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListSimpleDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建LinkedList对象，存储整数类型元素</span></span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 向集合中添加元素（支持尾部、头部添加，高效）</span></span><br><span class="line">        linkedList.add(<span class="number">10</span>); <span class="comment">// 尾部添加（普通添加方法）</span></span><br><span class="line">        linkedList.add(<span class="number">20</span>);</span><br><span class="line">        linkedList.addFirst(<span class="number">5</span>); <span class="comment">// 特有方法：头部添加（高效，对应“插入删除快”）</span></span><br><span class="line">        linkedList.addLast(<span class="number">25</span>); <span class="comment">// 特有方法：尾部添加（高效）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;初始LinkedList：&quot;</span> + linkedList);</span><br><span class="line">        <span class="comment">// 运行结果：初始LinkedList：[5, 10, 20, 25]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 核心优势：频繁增删（头部、尾部、指定位置，效率高于ArrayList）</span></span><br><span class="line">        linkedList.add(<span class="number">2</span>, <span class="number">15</span>); <span class="comment">// 在索引2的位置插入15（高效）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;索引2插入15后：&quot;</span> + linkedList);</span><br><span class="line">        <span class="comment">// 运行结果：索引2插入15后：[5, 10, 15, 20, 25]</span></span><br><span class="line"></span><br><span class="line">        linkedList.removeFirst(); <span class="comment">// 特有方法：删除头部元素（高效）</span></span><br><span class="line">        linkedList.removeLast(); <span class="comment">// 特有方法：删除尾部元素（高效）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除头尾元素后：&quot;</span> + linkedList);</span><br><span class="line">        <span class="comment">// 运行结果：删除头尾元素后：[10, 15, 20]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 查询元素（通过索引查询，效率低，对应表格“随机访问慢”，不推荐频繁使用）</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">element</span> <span class="operator">=</span> linkedList.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;索引1的元素：&quot;</span> + element);</span><br><span class="line">        <span class="comment">// 运行结果：索引1的元素：15</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 遍历集合（推荐增强for循环，避免索引查询，适配LinkedList特性）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;增强for循环遍历（适配LinkedList增删特性）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer num : linkedList) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运行结果：</span></span><br><span class="line">        <span class="comment">// 10</span></span><br><span class="line">        <span class="comment">// 15</span></span><br><span class="line">        <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-Set实现类"><a href="#2-Set实现类" class="headerlink" title="(2) Set实现类"></a>(2) Set实现类</h4><table>
<thead>
<tr>
<th>类型</th>
<th>底层结构</th>
<th>排序特性</th>
<th>线程安全</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HashSet</strong></td>
<td>HashMap</td>
<td>无序</td>
<td>❌</td>
<td>通过hashCode()快速查找</td>
</tr>
<tr>
<td><strong>LinkedHashSet</strong></td>
<td>LinkedHashMap</td>
<td>插入顺序</td>
<td>❌</td>
<td>保持插入顺序</td>
</tr>
<tr>
<td><strong>TreeSet</strong></td>
<td>TreeMap</td>
<td>自然排序</td>
<td>❌</td>
<td>通过红黑树实现</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>HashSet：无序、去重（底层 HashMap）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建HashSet对象，存储字符串类型</span></span><br><span class="line">        Set&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加元素（包含重复元素，演示去重特性）</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;Java&quot;</span>); <span class="comment">// 重复元素，添加失败</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;Go&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 打印集合（无序，且无重复元素“Java”）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;HashSet元素（无序+去重）：&quot;</span> + hashSet);</span><br><span class="line">        <span class="comment">// 运行结果（顺序不固定，示例参考）：HashSet元素（无序+去重）：[Java, Python, C++, Go]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 常用操作：判断元素是否存在、删除元素</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasPython</span> <span class="operator">=</span> hashSet.contains(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">        hashSet.remove(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否包含Python：&quot;</span> + hasPython);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除C++后HashSet：&quot;</span> + hashSet);</span><br><span class="line">        <span class="comment">// 运行结果：</span></span><br><span class="line">        <span class="comment">// 是否包含Python：true</span></span><br><span class="line">        <span class="comment">// 删除C++后HashSet：[Java, Python, Go]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LinkedHashSet：保持插入顺序、去重（底层 LinkedHashMap）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建LinkedHashSet对象</span></span><br><span class="line">        Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 按顺序添加元素（包含重复元素）</span></span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;Java&quot;</span>); <span class="comment">// 重复元素，添加失败</span></span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;Go&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 打印集合（与插入顺序完全一致，且去重）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedHashSet元素（插入顺序+去重）：&quot;</span> + linkedHashSet);</span><br><span class="line">        <span class="comment">// 运行结果（顺序固定）：LinkedHashSet元素（插入顺序+去重）：[Java, Python, C++, Go]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 遍历集合（顺序与插入一致）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历LinkedHashSet（保持插入顺序）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : linkedHashSet) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运行结果：Java -&gt; Python -&gt; C++ -&gt; Go（与插入顺序一致）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>TreeSet：自然排序、去重（底层 TreeMap，红黑树）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例1：存储整数，自然排序（升序）</span></span><br><span class="line">        Set&lt;Integer&gt; numTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        numTreeSet.add(<span class="number">30</span>);</span><br><span class="line">        numTreeSet.add(<span class="number">10</span>);</span><br><span class="line">        numTreeSet.add(<span class="number">20</span>);</span><br><span class="line">        numTreeSet.add(<span class="number">30</span>); <span class="comment">// 重复元素，添加失败</span></span><br><span class="line">        System.out.println(<span class="string">&quot;TreeSet整数（自然升序+去重）：&quot;</span> + numTreeSet);</span><br><span class="line">        <span class="comment">// 运行结果（固定升序）：TreeSet整数（自然升序+去重）：[10, 20, 30]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 示例2：存储字符串，自然排序（字典序）</span></span><br><span class="line">        Set&lt;String&gt; strTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        strTreeSet.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        strTreeSet.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">        strTreeSet.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        strTreeSet.add(<span class="string">&quot;Go&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;TreeSet字符串（字典序+去重）：&quot;</span> + strTreeSet);</span><br><span class="line">        <span class="comment">// 运行结果（固定字典序）：TreeSet字符串（字典序+去重）：[C++, Go, Java, Python]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-Map实现类"><a href="#3-Map实现类" class="headerlink" title="(3) Map实现类"></a>(3) Map实现类</h4><table>
<thead>
<tr>
<th>类型</th>
<th>底层结构</th>
<th>扩容机制</th>
<th>线程安全</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HashMap</strong></td>
<td>数组+链表+红黑树</td>
<td>2倍扩容</td>
<td>❌</td>
<td>最常用Map</td>
</tr>
<tr>
<td><strong>Hashtable</strong></td>
<td>数组+链表</td>
<td>2倍扩容</td>
<td>✅</td>
<td>同步，已过时</td>
</tr>
<tr>
<td><strong>ConcurrentHashMap</strong></td>
<td>分段锁（JDK7）<br>CAS+synchronized（JDK8）</td>
<td>2倍扩容</td>
<td>✅</td>
<td>高并发场景</td>
</tr>
<tr>
<td><strong>TreeMap</strong></td>
<td>红黑树</td>
<td>无</td>
<td>❌</td>
<td>按键排序</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>HashMap：最常用、无序、非线程安全（底层数组 + 链表 + 红黑树）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建HashMap对象，键：字符串（姓名），值：整数（年龄）</span></span><br><span class="line">        Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加键值对（增）</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;王五&quot;</span>, <span class="number">28</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;张三&quot;</span>, <span class="number">26</span>); <span class="comment">// 重复键，覆盖原有值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取值（查）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">zhangSanAge</span> <span class="operator">=</span> hashMap.get(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;张三的年龄：&quot;</span> + zhangSanAge);</span><br><span class="line">        <span class="comment">// 运行结果：张三的年龄：26（已覆盖原有值25）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 打印Map（无序存储）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap键值对（无序）：&quot;</span> + hashMap);</span><br><span class="line">        <span class="comment">// 运行结果（顺序不固定）：HashMap键值对（无序）：&#123;张三=26, 李四=30, 王五=28&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 修改值（改）</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;李四&quot;</span>, <span class="number">31</span>);</span><br><span class="line">        <span class="comment">// 6. 删除键值对（删）</span></span><br><span class="line">        hashMap.remove(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改+删除后HashMap：&quot;</span> + hashMap);</span><br><span class="line">        <span class="comment">// 运行结果：修改+删除后HashMap：&#123;张三=26, 李四=31&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 遍历Map</span></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历HashMap：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;键：&quot;</span> + entry.getKey() + <span class="string">&quot;，值：&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Hashtable：线程安全、已过时（底层数组 + 链表）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashtableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Hashtable对象</span></span><br><span class="line">        Map&lt;String, Integer&gt; hashtable = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加键值对（用法与HashMap类似）</span></span><br><span class="line">        hashtable.put(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;王五&quot;</span>, <span class="number">28</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;张三&quot;</span>, <span class="number">26</span>); <span class="comment">// 重复键，覆盖值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 打印Hashtable（无序）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hashtable键值对（线程安全+无序）：&quot;</span> + hashtable);</span><br><span class="line">        <span class="comment">// 运行结果：Hashtable键值对（线程安全+无序）：&#123;李四=30, 张三=26, 王五=28&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关键提醒：Hashtable已过时，不推荐使用，性能远低于ConcurrentHashMap</span></span><br><span class="line">        System.out.println(<span class="string">&quot;注意：Hashtable已过时，优先使用ConcurrentHashMap实现线程安全Map&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ConcurrentHashMap：高并发、线程安全（JDK8：CAS+synchronized）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> java.util.Map;</span><br><span class="line">  <span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">          <span class="comment">// 1. 创建ConcurrentHashMap对象</span></span><br><span class="line">          Map&lt;String, Integer&gt; concurrentHashMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 2. 演示多线程写入（体现高并发安全特性）</span></span><br><span class="line">          <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                  <span class="comment">// 并发写入，不会出现线程安全问题（如数据丢失、异常）</span></span><br><span class="line">                  concurrentHashMap.put(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + i, i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 3. 启动2个线程并发写入</span></span><br><span class="line">          <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">          <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">          t1.start();</span><br><span class="line">          t2.start();</span><br><span class="line">          t1.join();</span><br><span class="line">          t2.join();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 4. 打印元素个数（应为2000个，无数据丢失）</span></span><br><span class="line">          System.out.println(<span class="string">&quot;ConcurrentHashMap元素个数（并发写入无丢失）：&quot;</span> + concurrentHashMap.size());</span><br><span class="line">          <span class="comment">// 运行结果：ConcurrentHashMap元素个数（并发写入无丢失）：2000</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 5. 普通增删改查（用法与HashMap一致）</span></span><br><span class="line">          concurrentHashMap.put(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;张三的年龄：&quot;</span> + concurrentHashMap.get(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">          <span class="comment">// 运行结果：张三的年龄：25</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line">- **TreeMap：按键自然排序、非线程安全（底层红黑树）** </span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line">  <span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="comment">// 1. 创建TreeMap对象，键：字符串（姓名），值：整数（年龄）</span></span><br><span class="line">          Map&lt;String, Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 2. 添加键值对（键为字符串，按字典序排序）</span></span><br><span class="line">          treeMap.put(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">          treeMap.put(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>);</span><br><span class="line">          treeMap.put(<span class="string">&quot;王五&quot;</span>, <span class="number">28</span>);</span><br><span class="line">          treeMap.put(<span class="string">&quot;赵六&quot;</span>, <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 3. 打印TreeMap（按键自然排序：字典序）</span></span><br><span class="line">          System.out.println(<span class="string">&quot;TreeMap键值对（按键字典序排序）：&quot;</span> + treeMap);</span><br><span class="line">          <span class="comment">// 运行结果（固定字典序）：TreeMap键值对（按键字典序排序）：&#123;李四=30, 王五=28, 张三=25, 赵六=35&#125;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 4. 遍历TreeMap（按键升序遍历）</span></span><br><span class="line">          System.out.println(<span class="string">&quot;遍历TreeMap（按键排序）：&quot;</span>);</span><br><span class="line">          <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;键：&quot;</span> + entry.getKey() + <span class="string">&quot;，值：&quot;</span> + entry.getValue());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 示例2：键为整数，按升序排序</span></span><br><span class="line">          Map&lt;Integer, String&gt; numTreeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">          numTreeMap.put(<span class="number">3</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">          numTreeMap.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">          numTreeMap.put(<span class="number">2</span>, <span class="string">&quot;Python&quot;</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;TreeMap（键为整数，升序排序）：&quot;</span> + numTreeMap);</span><br><span class="line">          <span class="comment">// 运行结果：TreeMap（键为整数，升序排序）：&#123;1=Java, 2=Python, 3=C++&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="(5)总结"></a>(5)总结</h4><table>
<thead>
<tr>
<th>实现类</th>
<th>核心特性体现</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet</td>
<td>无序、去重</td>
<td>无需有序存储，仅需去重</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>插入顺序、去重</td>
<td>需要保留插入顺序且去重</td>
</tr>
<tr>
<td>TreeSet</td>
<td>自然排序、去重</td>
<td>需要有序存储且去重</td>
</tr>
<tr>
<td>HashMap</td>
<td>高效、无序、非线程安全</td>
<td>普通场景（单线程&#x2F;无并发）的键值对存储</td>
</tr>
<tr>
<td>Hashtable</td>
<td>线程安全、性能差、已过时</td>
<td>兼容旧系统，不推荐新开发使用</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>高并发、线程安全、性能优异</td>
<td>多线程并发写入&#x2F;读取的场景</td>
</tr>
<tr>
<td>TreeMap</td>
<td>按键自然排序、非线程安全</td>
<td>需要按键盘序遍历的键值对存储</td>
</tr>
</tbody></table>
<h2 id="五、面向对象深度解析"><a href="#五、面向对象深度解析" class="headerlink" title="五、面向对象深度解析"></a>五、面向对象深度解析</h2><h3 id="1-继承与多态"><a href="#1-继承与多态" class="headerlink" title="1. 继承与多态"></a>1. 继承与多态</h3><ul>
<li><p><strong>多态实现原理</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123; </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;Woof&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">a.sound(); <span class="comment">// 输出&quot;Woof&quot;（动态绑定）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JVM通过<strong>虚方法表（vtable）</strong> 实现</li>
<li>每个类有虚方法表，指向实际方法地址</li>
</ul>
</li>
<li><p><strong>super关键字详解</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Parent(String name) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Child() &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;Child&quot;</span>); <span class="comment">// 必须在第一行调用父类构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Override与super关键字</strong></p>
<ul>
<li><p><strong>Override</strong>：子类重写父类方法，必须与父类方法签名一致（返回值类型、方法名、参数列表）</p>
</li>
<li><p><strong>super</strong>：调用父类方法或构造器，必须在子类方法第一行（构造器中）</p>
</li>
<li><p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：定义基础方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 父类的问候方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类（Person）：你好！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：继承父类，并重写方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 使用 @Override 注解标注此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 使用 super 关键字调用父类的 sayHello() 方法</span></span><br><span class="line">        <span class="built_in">super</span>.sayHello();</span><br><span class="line">        <span class="comment">// 子类自己的扩展逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类（Student）：我是一名学生！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideAndSuperDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.sayHello(); <span class="comment">// 调用子类重写后的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际上是可以删除 <span class="meta">@Override</span> 注解的，因为它不是强制要求的。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2. 抽象类"></a>2. 抽象类</h3><ul>
<li><p><strong>抽象类定义</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法（无实现）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体方法（有实现）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>知识点</strong>：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.抽象类不能直接实例化（不能用 new AbstractClass() 创建对象），只能作为父类被子类继承。</span><br><span class="line">    补充：可通过“子类实例化+向上转型”的方式使用抽象类（如 AbstractAnimal animal = new Dog()）。</span><br><span class="line">2.成员组成:</span><br><span class="line">    抽象方法：用 abstract 修饰，无方法体（以分号结尾），表示“待子类实现的方法”，抽象类中可以有 0 个或多个抽象方法；不能被 private、final、static 修饰（会限制子类重写）。</span><br><span class="line">    普通方法：有完整方法体，供子类直接继承复用，无需子类重写（子类可按需重写，重写时遵循方法重写通用规则，访问权限不能比父类更严格）。</span><br><span class="line">    成员变量：支持普通成员变量（可修改，属于对象实例）、静态变量（static，属于抽象类本身，可通过类名直接访问），有默认初始化值。</span><br><span class="line">    构造器：存在构造器（用于子类初始化时，调用父类构造器初始化抽象类的成员变量），但不能用于实例化抽象类本身；子类构造器会默认隐式调用抽象类无参构造器（super()），若抽象类只有有参构造器，子类必须显式调用（super(参数)）且放在第一行。</span><br><span class="line">3.继承规则:</span><br><span class="line">    类继承抽象类时，要么自身也声明为抽象类（可遗留抽象方法，未实现的方法向下传递），要么必须实现抽象类的所有抽象方法。</span><br><span class="line">    Java 是单继承机制，一个子类只能继承一个抽象类（该规则适用于所有Java类，一个类仅有一个直接父类）。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-接口"><a href="#3-接口" class="headerlink" title="3. 接口"></a>3. 接口</h3><ul>
<li><p><strong>接口定义</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法（无实现）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认方法（有实现）</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>知识点</strong>：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 接口是一种引用类型，用于定义行为规范（抽象方法）。</span><br><span class="line">2. 接口不能直接实例化（不能用 new Interface() 创建对象），只能作为类型被实现或被其他接口继承。</span><br><span class="line">3. java8之前：</span><br><span class="line">    接口可以包含常量（默认 public static final）和抽象方法（默认 public abstract）。</span><br><span class="line">4. java8及以后：</span><br><span class="line">    在3的基础上，接口可以包含默认方法（default 修饰，有方法体）和静态方法（static 修饰，有方法体）。</span><br><span class="line">    注意：默认方法和静态方法不能使用 public abstract 修饰符（二者有方法体，与抽象方法特性冲突）；接口的抽象方法仍默认携带 public abstract 修饰符，可省略不写。</span><br><span class="line">5. 类实现接口时，必须实现接口中的所有抽象方法，否则类必须声明为抽象类。</span><br><span class="line">6. 接口可以继承其他接口，形成接口的层次结构。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-抽象类与接口的联系总结"><a href="#4-抽象类与接口的联系总结" class="headerlink" title="4. 抽象类与接口的联系总结"></a>4. 抽象类与接口的联系总结</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.  抽象类可以没有抽象方法（但通常会有普通方法）；即使无抽象方法，抽象类依然无法直接实例化。</span><br><span class="line">2.  抽象方法不能被 private/final/static 修饰（冲突特性）；核心原因：这三个修饰符会限制子类重写抽象方法（private不可访问、final不可重写、static不属于实例无法重写）。</span><br><span class="line">3.  抽象类的构造器不能私有化（否则无法被继承）。</span><br><span class="line">4.  抽象类可作为方法参数 / 返回值（体现多态）；实际传入/返回的是抽象类的子类实例（向上转型）。</span><br><span class="line">5.  抽象类可以继承抽象类:</span><br><span class="line">    子抽象类可选择性实现父抽象类的抽象方法（实现部分、实现全部、一个都不实现都可以），未实现的抽象方法会向下传递，由最终的非抽象子类统一实现。</span><br><span class="line">    从中也可以反映：抽象类可以有非抽象方法。</span><br><span class="line">6.  抽象类可以实现接口的部分方法:</span><br><span class="line">    抽象类可以实现接口的部分方法（即实现接口的抽象方法），甚至可以一个都不实现；未实现的方法可以在抽象类中保持抽象状态，继续向下传递。</span><br><span class="line">7.  普通类必须实现接口的所有抽象方法，否则类必须声明为抽象类。</span><br><span class="line">8.  普通类继承抽象类时，必须实现抽象类的所有抽象方法，否则类必须声明为抽象类；此处的“所有抽象方法”包括抽象类自身定义的、继承父抽象类遗留的、实现接口传递下来的所有未完成抽象方法。</span><br><span class="line">9.  类（普通类，内部类，抽象类）只能单继承，但可以实现多个接口。</span><br><span class="line">10. 接口与抽象类的抽象方法：</span><br><span class="line">    接口：</span><br><span class="line">      1.  抽象方法默认修饰符是 public abstract，可省略不写（三种写法等价：void method(); / public void method(); / public abstract void method();）。</span><br><span class="line">      2.  有且仅有 public abstract 这一种修饰符组合，不允许使用 private、protected 等其他任何修饰符，否则编译报错。</span><br><span class="line">      3.  子类重写该抽象方法时，必须使用 public 修饰符（权限不能更严格）。</span><br><span class="line">    抽象类：</span><br><span class="line">      1.  abstract 修饰符必须手动指定（不写则不是抽象方法），无默认的 public abstract/protected abstract 组合。</span><br><span class="line">      2.  访问修饰符支持 2 种：public、protected（可手动指定）；若不指定任何访问修饰符，默认是「包访问权限（default 权限，无关键字）」，非 protected。</span><br><span class="line">      3.  不支持的修饰符：private、final、static（与 abstract 互斥，编译报错）。</span><br><span class="line">      4.  子类重写该抽象方法时，访问权限不能比父类更严格（如父类 protected → 子类 protected/public；父类 public → 子类只能 public）。</span><br></pre></td></tr></table></figure>

<h2 id="六、异常处理解析"><a href="#六、异常处理解析" class="headerlink" title="六、异常处理解析"></a>六、异常处理解析</h2><h3 id="1-异常体系结构"><a href="#1-异常体系结构" class="headerlink" title="1. 异常体系结构"></a>1. 异常体系结构</h3><pre class="mermaid">graph TD
    Throwable --> Error
    Throwable --> Exception
    Error --> StackOverflowError
    Error --> OutOfMemoryError
    Exception --> RuntimeException
    RuntimeException --> NullPointerException
    RuntimeException --> ArrayIndexOutOfBoundsException
    Exception --> IOException
    Exception --> SQLException</pre>

<ul>
<li><strong>Checked Exception vs Unchecked Exception</strong>：<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>举例</th>
<th>处理要求</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Checked Exception</strong></td>
<td>编译时检查</td>
<td><code>IOException</code>, <code>SQLException</code></td>
<td>必须捕获或声明抛出</td>
</tr>
<tr>
<td><strong>Unchecked Exception</strong></td>
<td>运行时异常</td>
<td><code>NullPointerException</code>, <code>IllegalArgumentException</code></td>
<td>可选处理</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-异常处理最佳实践"><a href="#2-异常处理最佳实践" class="headerlink" title="2. 异常处理最佳实践"></a>2. 异常处理最佳实践</h3><ul>
<li><p><strong>try-with-resources（JDK7+）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 自动关闭资源</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常链式处理</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;处理失败&quot;</span>, e); <span class="comment">// 保留原始异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义异常</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">if</span> (invalidData) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;数据无效&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="七、内部类解析"><a href="#七、内部类解析" class="headerlink" title="七、内部类解析"></a>七、内部类解析</h2><h3 id="1-四种内部类详解"><a href="#1-四种内部类详解" class="headerlink" title="1. 四种内部类详解"></a>1. 四种内部类详解</h3><table>
<thead>
<tr>
<th>类型</th>
<th>定义位置</th>
<th>访问外部类成员</th>
<th>实例化方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>成员内部类</strong></td>
<td>类中方法外</td>
<td>✅ 可直接访问</td>
<td><code>Outer.Inner in = new Outer().new Inner();</code></td>
<td>需外部类实例</td>
</tr>
<tr>
<td><strong>静态内部类</strong></td>
<td>类中方法外+static</td>
<td>❌ 只能访问静态成员</td>
<td><code>Outer.StaticInner si = new Outer.StaticInner();</code></td>
<td>独立于外部类</td>
</tr>
<tr>
<td><strong>局部内部类</strong></td>
<td>方法内</td>
<td>✅ 可访问final局部变量</td>
<td><code>new Inner();</code>（仅在方法内）</td>
<td>作用域仅限方法</td>
</tr>
<tr>
<td><strong>匿名内部类</strong></td>
<td>无名，直接实例化</td>
<td>✅</td>
<td><code>new Interface() { ... }</code></td>
<td>适用于单次使用</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>成员内部类示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">outerField</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(outerField); <span class="comment">// 直接访问外部类私有成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.display();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>匿名内部类典型应用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8+ Lambda写法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Running&quot;</span>)).start();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="八、文件I-O与NIO-2"><a href="#八、文件I-O与NIO-2" class="headerlink" title="八、文件I&#x2F;O与NIO.2"></a>八、文件I&#x2F;O与NIO.2</h2><h3 id="1-传统IO流体系"><a href="#1-传统IO流体系" class="headerlink" title="1. 传统IO流体系"></a>1. 传统IO流体系</h3><table>
<thead>
<tr>
<th>类型</th>
<th>抽象类</th>
<th>具体实现</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字节流</strong></td>
<td><code>InputStream</code>&#x2F;<code>OutputStream</code></td>
<td><code>FileInputStream</code>&#x2F;<code>FileOutputStream</code></td>
<td>二进制数据</td>
</tr>
<tr>
<td><strong>字符流</strong></td>
<td><code>Reader</code>&#x2F;<code>Writer</code></td>
<td><code>FileReader</code>&#x2F;<code>FileWriter</code></td>
<td>文本数据</td>
</tr>
<tr>
<td><strong>缓冲流</strong></td>
<td><code>BufferedInputStream</code>&#x2F;<code>BufferedOutputStream</code></td>
<td><code>BufferedInputStream</code>&#x2F;<code>BufferedWriter</code></td>
<td>提高读写效率</td>
</tr>
<tr>
<td><strong>转换流</strong></td>
<td><code>InputStreamReader</code>&#x2F;<code>OutputStreamWriter</code></td>
<td><code>InputStreamReader</code>&#x2F;<code>OutputStreamWriter</code></td>
<td>字节→字符转换</td>
</tr>
</tbody></table>
<ul>
<li><strong>文件读写示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文本文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文本文件（追加模式）</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;file.txt&quot;</span>, <span class="literal">true</span>))) &#123;</span><br><span class="line">    bw.write(<span class="string">&quot;New line&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-NIO-2核心特性"><a href="#2-NIO-2核心特性" class="headerlink" title="2. NIO.2核心特性"></a>2. NIO.2核心特性</h3><ul>
<li><p><strong>Path与Files工具类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取所有行</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">Files.write(path, <span class="string">&quot;New content&quot;</span>.getBytes(), StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line">Files.copy(Paths.get(<span class="string">&quot;source.txt&quot;</span>), Paths.get(<span class="string">&quot;dest.txt&quot;</span>), StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异步文件操作</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousFileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;file.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">channel.read(buffer, <span class="number">0</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, Object attachment)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Read &quot;</span> + result + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h2><h3 id="类型擦除原理"><a href="#类型擦除原理" class="headerlink" title="类型擦除原理"></a><strong>类型擦除原理</strong></h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后实际为：</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 类型信息被擦除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">System.out.println(list1.getClass() == list2.getClass()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 因为擦除后，两者都是 ArrayList 类型，JVM 无法区分它们的泛型参数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>泛型基础</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无标签的盒子：什么都能装</span></span><br><span class="line"><span class="type">List</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">box.add(<span class="string">&quot;苹果&quot;</span>);     <span class="comment">// ✅ 水果</span></span><br><span class="line">box.add(<span class="number">123</span>);        <span class="comment">// ✅ 编译通过！但这是数字，不是水果！</span></span><br><span class="line">box.add(<span class="keyword">new</span> <span class="title class_">Car</span>());  <span class="comment">// ✅ 编译通过！但这是汽车，不是水果！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出时需要手动类型转换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> (String) box.get(<span class="number">0</span>); <span class="comment">// ✅ 正常</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) box.get(<span class="number">1</span>);         <span class="comment">// ❌ 运行时错误！int 不能直接转 Object</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (Integer) box.get(<span class="number">1</span>); <span class="comment">// 编译通过，但运行时可能崩溃！所以还是要特定的泛型存储特定的类型</span></span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) box.get(<span class="number">2</span>);         <span class="comment">// ✅ 正常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带“水果标签”的盒子：只能装 String 类型</span></span><br><span class="line">List&lt;String&gt; fruitBox = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">fruitBox.add(<span class="string">&quot;苹果&quot;</span>); <span class="comment">// ✅ 符合标签：String 类型</span></span><br><span class="line">fruitBox.add(<span class="number">123</span>);    <span class="comment">// ❌ 编译直接报错！123 不是 String 类型</span></span><br><span class="line">fruitBox.add(<span class="keyword">new</span> <span class="title class_">Car</span>());<span class="comment">// ❌ 编译直接报错！Car 不是 String 类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitBox.get(<span class="number">0</span>); <span class="comment">// 取出时无需强制转换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用泛型定义“只能装 Integer 的盒子”</span></span><br><span class="line">List&lt;Integer&gt; numberBox = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">numberBox.add(<span class="number">123</span>); <span class="comment">// ✅ 编译通过（123 自动装箱为 Integer）</span></span><br><span class="line"><span class="comment">// numberBox.add(&quot;abc&quot;); // ❌ 编译报错！类型不匹配</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> numberBox.get(<span class="number">0</span>); <span class="comment">// // 取出时直接得到 int（自动拆箱）</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="绕过类型擦除获取泛型类型"><a href="#绕过类型擦除获取泛型类型" class="headerlink" title="绕过类型擦除获取泛型类型"></a><strong>绕过类型擦除获取泛型类型</strong></h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeReference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">TypeReference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">superclass</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">        type = ((ParameterizedType) superclass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Type <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">TypeReference&lt;List&lt;String&gt;&gt; ref = <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;&gt;() &#123;&#125;;</span><br><span class="line">System.out.println(ref.getType()); <span class="comment">// 输出：java.util.List&lt;java.lang.String&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="十、Lambda表达式-java-8"><a href="#十、Lambda表达式-java-8" class="headerlink" title="十、Lambda表达式(java 8+)"></a>十、Lambda表达式(java 8+)</h2><p>Lambda 表达式是 <strong>Java 8 引入的函数式编程特性</strong>，用于简化匿名内部类的写法。它的核心本质是：  </p>
<blockquote>
<p><strong>将“行为”作为参数传递</strong>，让代码更简洁、更易读。</p>
</blockquote>
<h3 id="Lambda-表达式通用语法"><a href="#Lambda-表达式通用语法" class="headerlink" title="Lambda 表达式通用语法"></a><strong>Lambda 表达式通用语法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) -&gt; &#123; 代码块 &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>(参数列表)</code></strong>：函数的输入参数（可省略类型，由编译器自动推断）</li>
<li><strong><code>-&gt;</code></strong>：箭头操作符（固定写法）</li>
<li><strong><code>{ 代码块 }</code></strong>：函数体（单行表达式可省略 <code>{}</code> 和 <code>return</code>）</li>
</ul>
<h3 id="语法简化规则"><a href="#语法简化规则" class="headerlink" title="语法简化规则"></a><strong>语法简化规则</strong></h3><h4 id="1️⃣-完整版（带类型和代码块）"><a href="#1️⃣-完整版（带类型和代码块）" class="headerlink" title="1️⃣ 完整版（带类型和代码块）"></a>1️⃣ <strong>完整版（带类型和代码块）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整写法：参数类型明确 + 代码块 + return</span></span><br><span class="line">(<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123; </span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2️⃣-省略参数类型（编译器自动推断）"><a href="#2️⃣-省略参数类型（编译器自动推断）" class="headerlink" title="2️⃣ 省略参数类型（编译器自动推断）"></a>2️⃣ <strong>省略参数类型（编译器自动推断）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略参数类型：a, b 的类型由上下文推断为 int</span></span><br><span class="line">(a, b) -&gt; &#123; </span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3️⃣-单参数省略括号"><a href="#3️⃣-单参数省略括号" class="headerlink" title="3️⃣ 单参数省略括号"></a>3️⃣ <strong>单参数省略括号</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单参数时可省略括号</span></span><br><span class="line">x -&gt; x * <span class="number">2</span>  <span class="comment">// 等价于 (x) -&gt; &#123; return x * 2; &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="4️⃣-单行表达式省略-return-和"><a href="#4️⃣-单行表达式省略-return-和" class="headerlink" title="4️⃣ 单行表达式省略 return 和 {}"></a>4️⃣ <strong>单行表达式省略 return 和 {}</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行表达式可省略 return 和 &#123;&#125;</span></span><br><span class="line">x -&gt; x * <span class="number">2</span>  <span class="comment">// 等价于 x -&gt; &#123; return x * 2; &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="5️⃣-无参数时用空括号"><a href="#5️⃣-无参数时用空括号" class="headerlink" title="5️⃣ 无参数时用空括号"></a>5️⃣ <strong>无参数时用空括号</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>) </span><br><span class="line"><span class="comment">// 等价于 new Runnable() &#123; public void run() &#123; System.out.println(&quot;Hello&quot;); &#125; &#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="经典场景示例"><a href="#经典场景示例" class="headerlink" title="经典场景示例"></a><strong>经典场景示例</strong></h3><h4 id="✅-场景-1：函数式接口实现"><a href="#✅-场景-1：函数式接口实现" class="headerlink" title="✅ 场景 1：函数式接口实现"></a>✅ <strong>场景 1：函数式接口实现</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数式接口（只有一个抽象方法）</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MathOperation</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 实现</span></span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">add</span> <span class="operator">=</span> (a, b) -&gt; a + b;      <span class="comment">// 简化版</span></span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">multiply</span> <span class="operator">=</span> (a, b) -&gt; a * b; <span class="comment">// 单行表达式</span></span><br><span class="line"></span><br><span class="line">System.out.println(add.operate(<span class="number">2</span>, <span class="number">3</span>));      <span class="comment">// 5</span></span><br><span class="line">System.out.println(multiply.operate(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h4 id="✅-场景-2：Stream-API-过滤"><a href="#✅-场景-2：Stream-API-过滤" class="headerlink" title="✅ 场景 2：Stream API 过滤"></a>✅ <strong>场景 2：Stream API 过滤</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤偶数：x -&gt; x % 2 == 0</span></span><br><span class="line">List&lt;Integer&gt; evenNumbers = numbers.stream()</span><br><span class="line">    .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 单参数 + 单行表达式</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(evenNumbers); <span class="comment">// [2, 4]</span></span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 过滤偶数，平方，求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">    .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    .map(n -&gt; n * n)</span><br><span class="line">    .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 并行流处理（大数据量加速）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">parallelSum</span> <span class="operator">=</span> numbers.parallelStream()</span><br><span class="line">    .mapToInt(n -&gt; n * n)</span><br><span class="line">    .sum();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="✅-场景-3：多参数-代码块"><a href="#✅-场景-3：多参数-代码块" class="headerlink" title="✅ 场景 3：多参数 + 代码块"></a>✅ <strong>场景 3：多参数 + 代码块</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要多行逻辑时用代码块</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = (a, b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">System.out.println(comparator.compare(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h4 id="✅-场景-4：无参数（如-Runnable）"><a href="#✅-场景-4：无参数（如-Runnable）" class="headerlink" title="✅ 场景 4：无参数（如 Runnable）"></a>✅ <strong>场景 4：无参数（如 Runnable）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Running&quot;</span>)).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于传统匿名内部类：</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>



<h3 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a><strong>关键注意事项</strong></h3><table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>必须是函数式接口</strong></td>
<td>Lambda 只能用于 <strong>只有一个抽象方法的接口</strong>（用 <code>@FunctionalInterface</code> 标注）</td>
<td><code>Runnable</code>, <code>Comparator</code>, <code>Predicate</code> 等</td>
</tr>
<tr>
<td><strong>访问外部变量必须是 final 或 effectively final</strong></td>
<td>Lambda 内部不能修改外部变量（只能读取）</td>
<td><code>int x = 10;</code><br><code>() -&gt; System.out.println(x); // ✅</code><br><code>x = 20; // ❌ 编译错误</code></td>
</tr>
<tr>
<td><strong>不能声明新变量</strong></td>
<td>Lambda 表达式中不能声明新变量（如 <code>int y = 5;</code>）</td>
<td><code>x -&gt; { int y = x; return y; } // ❌ 编译错误</code></td>
</tr>
<tr>
<td><strong>方法引用是 Lambda 的简写</strong></td>
<td>用 <code>::</code> 操作符引用已有方法</td>
<td><code>System.out::println</code> 等价于 <code>x -&gt; System.out.println(x)</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="Lambda语法总结"><a href="#Lambda语法总结" class="headerlink" title="Lambda语法总结"></a><strong>Lambda语法总结</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) -&gt; &#123; 表达式或代码块 &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>参数列表</strong>：可省略类型，单参数省略括号  </li>
<li><strong>箭头 <code>-&gt;</code></strong>：固定符号  </li>
<li><strong>函数体</strong>：单行表达式省略 <code>{}</code> 和 <code>return</code></li>
</ul>
<h2 id="十一、Optional类使用"><a href="#十一、Optional类使用" class="headerlink" title="十一、Optional类使用"></a>十一、Optional类使用</h2><h3 id="Optional-类深度解析：彻底告别-NPE（空指针异常）"><a href="#Optional-类深度解析：彻底告别-NPE（空指针异常）" class="headerlink" title="Optional 类深度解析：彻底告别 NPE（空指针异常）"></a><strong><code>Optional</code> 类深度解析：彻底告别 NPE（空指针异常）</strong></h3><blockquote>
<p>✅ <strong>核心理念</strong>：<br><strong><code>Optional</code> 是 Java 8 引入的「容器类」，用于显式表达「值可能存在也可能不存在」</strong>，强制开发者处理空值场景，从根源上杜绝 <code>NullPointerException</code>。</p>
</blockquote>
<hr>
<h3 id="为什么需要-Optional？"><a href="#为什么需要-Optional？" class="headerlink" title="为什么需要 Optional？"></a><strong>为什么需要 <code>Optional</code>？</strong></h3><h4 id="传统空值处理的痛点"><a href="#传统空值处理的痛点" class="headerlink" title="传统空值处理的痛点"></a><strong>传统空值处理的痛点</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式：到处写 null 检查，代码臃肿且易遗漏</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.getAddress() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.getAddress().getCity() != <span class="literal">null</span>) &#123;</span><br><span class="line">            name = user.getAddress().getCity().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>问题</strong>：  <ul>
<li>代码冗长、可读性差  </li>
<li>容易遗漏检查（导致运行时 NPE）  </li>
<li><strong>null 语义不明确</strong>：无法区分「故意为 null」还是「忘记处理」</li>
</ul>
</li>
</ul>
<h4 id="Optional-的解决方案"><a href="#Optional-的解决方案" class="headerlink" title="Optional 的解决方案"></a><strong><code>Optional</code> 的解决方案</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Optional 链式调用，语义清晰且安全</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Optional.ofNullable(user)</span><br><span class="line">    .map(User::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .orElse(<span class="string">&quot;未知城市&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优势</strong>：  <ul>
<li><strong>强制处理空值</strong>：编译器要求你显式处理 <code>null</code> 场景  </li>
<li><strong>链式调用</strong>：避免多层嵌套 <code>if</code>  </li>
<li><strong>语义明确</strong>：<code>Optional</code> 本身表示「可能为空」，代码自解释</li>
</ul>
</li>
</ul>
<h3 id="Optional-核心方法"><a href="#Optional-核心方法" class="headerlink" title="Optional 核心方法"></a><strong><code>Optional</code> 核心方法</strong></h3><h4 id="1️⃣-创建-Optional-实例"><a href="#1️⃣-创建-Optional-实例" class="headerlink" title="1️⃣ 创建 Optional 实例"></a>1️⃣ <strong>创建 <code>Optional</code> 实例</strong></h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>示例</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>Optional.of(T value)</code></td>
<td>包装非 null 值</td>
<td><code>Optional.of(&quot;Hello&quot;)</code></td>
<td><strong>值一定不为 null</strong>（否则抛 <code>NullPointerException</code>）</td>
</tr>
<tr>
<td><code>Optional.ofNullable(T value)</code></td>
<td>包装可能为 null 的值</td>
<td><code>Optional.ofNullable(user)</code></td>
<td><strong>值可能为 null</strong>（安全创建）</td>
</tr>
<tr>
<td><code>Optional.empty()</code></td>
<td>创建空 Optional</td>
<td><code>Optional.empty()</code></td>
<td>显式表示「无值」</td>
</tr>
</tbody></table>
<h4 id="2️⃣-安全获取值"><a href="#2️⃣-安全获取值" class="headerlink" title="2️⃣ 安全获取值"></a>2️⃣ <strong>安全获取值</strong></h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>示例</th>
<th>风险</th>
</tr>
</thead>
<tbody><tr>
<td><code>T get()</code></td>
<td>直接获取值</td>
<td><code>optional.get()</code></td>
<td>⚠️ <strong>若为空则抛 <code>NoSuchElementException</code></strong>（不推荐！）</td>
</tr>
<tr>
<td><code>T orElse(T other)</code></td>
<td>有值返回值，无值返回默认值</td>
<td><code>optional.orElse(&quot;default&quot;)</code></td>
<td>安全（推荐）</td>
</tr>
<tr>
<td><code>T orElseGet(Supplier supplier)</code></td>
<td>有值返回值，无值执行 Supplier 生成默认值</td>
<td><code>optional.orElseGet(() -&gt; generateDefault())</code></td>
<td>延迟计算（默认值创建成本高时用）</td>
</tr>
<tr>
<td><code>T orElseThrow(Supplier exceptionSupplier)</code></td>
<td>有值返回值，无值抛异常</td>
<td><code>optional.orElseThrow(() -&gt; new CustomException())</code></td>
<td>需显式处理异常</td>
</tr>
</tbody></table>
<h4 id="3️⃣-转换值（避免嵌套）"><a href="#3️⃣-转换值（避免嵌套）" class="headerlink" title="3️⃣ 转换值（避免嵌套）"></a>3️⃣ <strong>转换值（避免嵌套）</strong></h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>示例</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>Optional&lt;U&gt; map(Function mapper)</code></td>
<td>对值应用函数（返回新 Optional）</td>
<td><code>optional.map(String::toUpperCase)</code></td>
<td><strong>链式调用</strong>（如 <code>user.getAddress().getCity()</code>）</td>
</tr>
<tr>
<td><code>Optional&lt;U&gt; flatMap(Function mapper)</code></td>
<td>对值应用返回 Optional 的函数</td>
<td><code>optional.flatMap(User::getAddress)</code></td>
<td>值本身是 Optional 时使用</td>
</tr>
</tbody></table>
<h4 id="4️⃣-条件处理（无值-有值时操作）"><a href="#4️⃣-条件处理（无值-有值时操作）" class="headerlink" title="4️⃣ 条件处理（无值&#x2F;有值时操作）"></a>4️⃣ <strong>条件处理（无值&#x2F;有值时操作）</strong></h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>示例</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>void ifPresent(Consumer consumer)</code></td>
<td>值存在时执行操作</td>
<td><code>optional.ifPresent(name -&gt; System.out.println(name))</code></td>
<td>仅需处理非空场景</td>
</tr>
<tr>
<td><code>void ifPresentOrElse(Consumer, Runnable)</code></td>
<td>有值执行 Consumer，无值执行 Runnable</td>
<td><code>optional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(&quot;空值&quot;))</code></td>
<td>完整处理空&#x2F;非空场景</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt; filter(Predicate predicate)</code></td>
<td>过滤值（不符合条件则变空）</td>
<td><code>optional.filter(name -&gt; name.length() &gt; 3)</code></td>
<td>验证值是否符合规则</td>
</tr>
</tbody></table>
<hr>
<h3 id="传统-vs-Optional"><a href="#传统-vs-Optional" class="headerlink" title="传统 vs Optional"></a><strong>传统 vs Optional</strong></h3><h4 id="场景-1：嵌套对象取值"><a href="#场景-1：嵌套对象取值" class="headerlink" title="场景 1：嵌套对象取值"></a><strong>场景 1：嵌套对象取值</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式（易遗漏 null 检查）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> <span class="string">&quot;未知&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span> &amp;&amp; user.getAddress() != <span class="literal">null</span> &amp;&amp; user.getAddress().getCity() != <span class="literal">null</span>) &#123;</span><br><span class="line">    city = user.getAddress().getCity().getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional 方式（编译器强制处理，安全简洁）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> Optional.ofNullable(user)</span><br><span class="line">    .map(User::getAddress)</span><br><span class="line">    .map(Address::getCity)</span><br><span class="line">    .map(City::getName)</span><br><span class="line">    .orElse(<span class="string">&quot;未知&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="场景-2：从-Map-中安全取值"><a href="#场景-2：从-Map-中安全取值" class="headerlink" title="场景 2：从 Map 中安全取值"></a><strong>场景 2：从 Map 中安全取值</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; config = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式（需两次 null 检查）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (config != <span class="literal">null</span> &amp;&amp; config.get(<span class="string">&quot;timeout&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">    value = config.get(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional 方式（一行代码解决）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Optional.ofNullable(config)</span><br><span class="line">    .map(map -&gt; map.get(<span class="string">&quot;timeout&quot;</span>))</span><br><span class="line">    .orElse(<span class="string">&quot;30s&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="场景-3：处理数据库查询结果（可能为空）"><a href="#场景-3：处理数据库查询结果（可能为空）" class="headerlink" title="场景 3：处理数据库查询结果（可能为空）"></a><strong>场景 3：处理数据库查询结果（可能为空）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式（冗长且易错）</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findById(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 user</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional 方式（语义清晰）</span></span><br><span class="line">Optional&lt;User&gt; userOpt = userRepository.findById(<span class="number">100</span>);</span><br><span class="line">userOpt.ifPresent(user -&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理 user</span></span><br><span class="line">&#125;);</span><br><span class="line">userOpt.orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UserNotFoundException</span>(<span class="string">&quot;ID 100 不存在&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Optional-使用规则"><a href="#Optional-使用规则" class="headerlink" title="Optional 使用规则"></a><strong><code>Optional</code> 使用规则</strong></h3><table>
<thead>
<tr>
<th>误区</th>
<th>正确做法</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>❌ 用 <code>Optional</code> 作为类的成员变量</td>
<td>✅ <strong>仅用于方法返回值</strong></td>
<td><code>Optional</code> 不可序列化，且违背设计初衷（字段应明确表示是否可空）</td>
</tr>
<tr>
<td>❌ 使用 <code>optional.get()</code></td>
<td>✅ <strong>永远用 <code>orElse</code>&#x2F;<code>orElseGet</code>&#x2F;<code>orElseThrow</code></strong></td>
<td><code>get()</code> 会抛异常，和直接用 <code>null</code> 无区别</td>
</tr>
<tr>
<td>❌ 用 <code>Optional</code> 包装集合</td>
<td>✅ <strong>集合返回空集合（<code>Collections.emptyList()</code>）</strong></td>
<td>集合的空值语义应由空集合表示，而非 <code>Optional</code></td>
</tr>
<tr>
<td>❌ 用 <code>Optional</code> 替代基础类型判断</td>
<td>✅ <strong>用基本类型特化版本（<code>OptionalInt</code>&#x2F;<code>OptionalDouble</code>）</strong></td>
<td>基本类型包装会损失性能（<code>OptionalInt</code> 无装箱开销）</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>关键原则</strong>：<br><strong><code>Optional</code> 是方法返回值的「语义增强器」，不是 null 的替代品！</strong>  </p>
<ul>
<li><strong>方法返回 <code>Optional&lt;T&gt;</code></strong> → 明确告诉调用者：「这个值可能为空」  </li>
<li><strong>方法返回 <code>T</code></strong> → 明确告诉调用者：「这个值一定不为空」</li>
</ul>
</blockquote>
<h3 id="使用事例"><a href="#使用事例" class="headerlink" title="使用事例"></a><strong>使用事例</strong></h3><h4 id="正确使用场景"><a href="#正确使用场景" class="headerlink" title="正确使用场景"></a><strong>正确使用场景</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法返回 Optional（明确表示可能为空）</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findById(id);</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(user); <span class="comment">// 显式表示可能为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方安全处理</span></span><br><span class="line">Optional&lt;User&gt; userOpt = findUserById(<span class="number">100</span>);</span><br><span class="line">userOpt.ifPresent(user -&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理 user</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="链式调用示例"><a href="#链式调用示例" class="headerlink" title="链式调用示例"></a><strong>链式调用示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置中获取用户默认语言（可能为空）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lang</span> <span class="operator">=</span> Optional.ofNullable(config)</span><br><span class="line">    .map(c -&gt; c.get(<span class="string">&quot;language&quot;</span>))</span><br><span class="line">    .filter(s -&gt; !s.isEmpty())</span><br><span class="line">    .orElse(<span class="string">&quot;zh-CN&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从订单中获取最后修改时间（可能为空）</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> Optional.ofNullable(order)</span><br><span class="line">    .map(Order::getModifiedTime)</span><br><span class="line">    .orElse(LocalDateTime.now());</span><br></pre></td></tr></table></figure>

<h4 id="避免过度使用"><a href="#避免过度使用" class="headerlink" title="避免过度使用"></a><strong>避免过度使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范：用 Optional 包装非空字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;String&gt; name; <span class="comment">// 不要这样！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法：字段用 null 表示空，方法返回 Optional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 允许为 null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th>传统代码</th>
<th><code>Optional</code> 代码</th>
<th>本质差异</th>
</tr>
</thead>
<tbody><tr>
<td><code>String name = user.getName();</code></td>
<td><code>String name = Optional.ofNullable(user).map(User::getName).orElse(&quot;Unknown&quot;);</code></td>
<td><strong>强制显式处理空值</strong>：编译器要求你写 <code>orElse</code>&#x2F;<code>ifPresent</code> 等，否则无法编译通过</td>
</tr>
<tr>
<td><code>if (user != null) { ... }</code></td>
<td><code>userOpt.ifPresent(u -&gt; { ... });</code></td>
<td><strong>代码结构明确</strong>：<code>ifPresent</code> 语义清晰，避免嵌套 <code>if</code></td>
</tr>
</tbody></table>
<h2 id="十二、Java-8-新特性详解"><a href="#十二、Java-8-新特性详解" class="headerlink" title="十二、Java 8+ 新特性详解"></a>十二、Java 8+ 新特性详解</h2><h3 id="1-日期时间API（java-time）"><a href="#1-日期时间API（java-time）" class="headerlink" title="1. 日期时间API（java.time）"></a>1. 日期时间API（java.time）</h3><ul>
<li><p><strong>核心类</strong>：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>LocalDate</code></td>
<td>日期（年月日）</td>
<td><code>LocalDate.now()</code></td>
</tr>
<tr>
<td><code>LocalTime</code></td>
<td>时间（时分秒）</td>
<td><code>LocalTime.of(10, 30)</code></td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td>日期+时间</td>
<td><code>LocalDateTime.now()</code></td>
</tr>
<tr>
<td><code>ZonedDateTime</code></td>
<td>带时区的日期时间</td>
<td><code>ZonedDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;))</code></td>
</tr>
<tr>
<td><code>Duration</code></td>
<td>时间段（秒&#x2F;纳秒）</td>
<td><code>Duration.between(start, end)</code></td>
</tr>
<tr>
<td><code>Period</code></td>
<td>日期段（年月日）</td>
<td><code>Period.between(date1, date2)</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>日期时间格式化</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> now.format(formatter);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-并发工具类"><a href="#2-并发工具类" class="headerlink" title="2. 并发工具类"></a>2. 并发工具类</h3><ul>
<li><p><strong>CompletableFuture</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">&#125;).thenApply(result -&gt; result.toUpperCase())</span><br><span class="line"> .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>StampedLock</strong>（读写锁优化）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlockRead(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="十三、JVM性能调优关键点"><a href="#十三、JVM性能调优关键点" class="headerlink" title="十三、JVM性能调优关键点"></a>十三、JVM性能调优关键点</h2><h3 id="1-内存参数配置"><a href="#1-内存参数配置" class="headerlink" title="1. 内存参数配置"></a>1. 内存参数配置</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Xms</code></td>
<td>初始堆大小</td>
<td><code>-Xms512m</code></td>
</tr>
<tr>
<td><code>-Xmx</code></td>
<td>最大堆大小</td>
<td><code>-Xmx2g</code></td>
</tr>
<tr>
<td><code>-XX:NewRatio</code></td>
<td>新生代&#x2F;老年代比例</td>
<td><code>-XX:NewRatio=2</code></td>
</tr>
<tr>
<td><code>-XX:MaxMetaspaceSize</code></td>
<td>元空间最大大小</td>
<td><code>-XX:MaxMetaspaceSize=256m</code></td>
</tr>
<tr>
<td><code>-XX:+UseG1GC</code></td>
<td>启用G1垃圾回收器</td>
<td><code>-XX:+UseG1GC</code></td>
</tr>
</tbody></table>
<h3 id="2-常见内存问题诊断"><a href="#2-常见内存问题诊断" class="headerlink" title="2. 常见内存问题诊断"></a>2. 常见内存问题诊断</h3><ul>
<li><p><strong>OutOfMemoryError</strong>：</p>
<ul>
<li><strong>堆内存溢出</strong>：<code>java.lang.OutOfMemoryError: Java heap space</code><ul>
<li>解决：增大<code>-Xmx</code>，检查内存泄漏</li>
</ul>
</li>
<li><strong>元空间溢出</strong>：<code>java.lang.OutOfMemoryError: Metaspace</code><ul>
<li>解决：增大<code>-XX:MaxMetaspaceSize</code></li>
</ul>
</li>
<li><strong>栈溢出</strong>：<code>java.lang.StackOverflowError</code><ul>
<li>解决：增大<code>-Xss</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内存泄漏诊断工具</strong>：</p>
<ul>
<li><code>jmap -heap &lt;pid&gt;</code>：查看堆内存使用</li>
<li><code>jstat -gc &lt;pid&gt; 1000</code>：实时监控GC情况</li>
<li><code>jvisualvm</code>：图形化分析内存快照</li>
</ul>
</li>
</ul>
<h2 id="十四、设计模式的应用"><a href="#十四、设计模式的应用" class="headerlink" title="十四、设计模式的应用"></a>十四、设计模式的应用</h2><h3 id="1-单例模式（双重检查锁）"><a href="#1-单例模式（双重检查锁）" class="headerlink" title="1. 单例模式（双重检查锁）"></a>1. 单例模式（双重检查锁）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-工厂模式（简单工厂）"><a href="#2-工厂模式（简单工厂）" class="headerlink" title="2. 工厂模式（简单工厂）"></a>2. 工厂模式（简单工厂）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Circle&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;circle&quot;</span>.equals(type)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;rectangle&quot;</span>.equals(type)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-观察者模式（Java内置实现）"><a href="#3-观察者模式（Java内置实现）" class="headerlink" title="3. 观察者模式（Java内置实现）"></a>3. 观察者模式（Java内置实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        setChanged(); <span class="comment">// 标记已更改</span></span><br><span class="line">        notifyObservers(state); <span class="comment">// 通知所有观察者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverImpl</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;State changed to: &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十五、反射机制深度解析"><a href="#十五、反射机制深度解析" class="headerlink" title="十五、反射机制深度解析"></a>十五、反射机制深度解析</h2><h3 id="1-反射核心API"><a href="#1-反射核心API" class="headerlink" title="1. 反射核心API"></a>1. 反射核心API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Class对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;myMethod&quot;</span>, String.class);</span><br><span class="line">method.invoke(obj, <span class="string">&quot;param&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问私有字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(obj, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-反射应用场景"><a href="#2-反射应用场景" class="headerlink" title="2. 反射应用场景"></a>2. 反射应用场景</h3><ul>
<li><strong>框架开发</strong>：Spring IOC依赖注入</li>
<li><strong>动态代理</strong>：JDK动态代理</li>
<li><strong>序列化&#x2F;反序列化</strong>：JSON库（如Jackson）</li>
<li><strong>单元测试</strong>：访问私有成员</li>
</ul>
<h3 id="3-反射性能优化"><a href="#3-反射性能优化" class="headerlink" title="3. 反射性能优化"></a>3. 反射性能优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 缓存Method对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">METHOD</span> <span class="operator">=</span> MyClass.class.getMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用MethodHandle（JDK7+）</span></span><br><span class="line"><span class="type">MethodHandle</span> <span class="variable">handle</span> <span class="operator">=</span> MethodHandles.lookup().findVirtual(MyClass.class, <span class="string">&quot;method&quot;</span>, MethodType.methodType(<span class="keyword">void</span>.class));</span><br><span class="line">handle.invokeExact(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用VarHandle（JDK9+）进行字段访问</span></span><br><span class="line"><span class="type">VarHandle</span> <span class="variable">handle</span> <span class="operator">=</span> MethodHandles.lookup().findVarHandle(MyClass.class, <span class="string">&quot;field&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">handle.set(obj, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="十六、JVM内存模型（JMM）"><a href="#十六、JVM内存模型（JMM）" class="headerlink" title="十六、JVM内存模型（JMM）"></a>十六、JVM内存模型（JMM）</h2><h3 id="1-主内存与工作内存"><a href="#1-主内存与工作内存" class="headerlink" title="1. 主内存与工作内存"></a>1. 主内存与工作内存</h3><pre class="mermaid">graph LR
    A[主内存] --> B[线程1工作内存]
    A --> C[线程2工作内存]
    B -->|读取| A
    C -->|读取| A
    B -->|写入| A
    C -->|写入| A</pre>

<h3 id="2-关键内存屏障"><a href="#2-关键内存屏障" class="headerlink" title="2. 关键内存屏障"></a>2. 关键内存屏障</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>LoadLoad</code></td>
<td>确保加载指令顺序</td>
<td>读取共享变量前</td>
</tr>
<tr>
<td><code>StoreStore</code></td>
<td>确保存储指令顺序</td>
<td>写入共享变量后</td>
</tr>
<tr>
<td><code>LoadStore</code></td>
<td>确保加载在存储前完成</td>
<td>读写混合操作</td>
</tr>
<tr>
<td><code>StoreLoad</code></td>
<td>最强屏障，防止重排序</td>
<td>volatile写后读</td>
</tr>
</tbody></table>
<h3 id="3-volatile关键字原理"><a href="#3-volatile关键字原理" class="headerlink" title="3. volatile关键字原理"></a>3. volatile关键字原理</h3><ul>
<li><strong>保证可见性</strong>：写入时刷新到主内存，读取时从主内存加载</li>
<li><strong>禁止指令重排序</strong>：通过内存屏障实现</li>
<li><strong>不保证原子性</strong>：如<code>i++</code>操作（包含读-改-写三步）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确使用volatile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化操作</span></span><br><span class="line">    initialized = <span class="literal">true</span>; <span class="comment">// 写入volatile变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialized) &#123; <span class="comment">// 读取volatile变量</span></span><br><span class="line">        <span class="comment">// 可以安全使用初始化数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十七、Java并发编程核心"><a href="#十七、Java并发编程核心" class="headerlink" title="十七、Java并发编程核心"></a>十七、Java并发编程核心</h2><h3 id="1-synchronized底层原理"><a href="#1-synchronized底层原理" class="headerlink" title="1. synchronized底层原理"></a>1. synchronized底层原理</h3><ul>
<li><strong>对象头结构</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Mark Word][Class Pointer][Lock Record]</span><br></pre></td></tr></table></figure></li>
<li><strong>锁升级过程</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无锁 → 偏向锁 → 轻量级锁 → 重量级锁</span><br></pre></td></tr></table></figure></li>
<li><strong>锁消除</strong>（JIT优化）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码会被优化为无锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">new</span> <span class="title class_">Object</span>()) &#123;</span><br><span class="line">        <span class="comment">// 无共享数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-Lock接口与AQS"><a href="#2-Lock接口与AQS" class="headerlink" title="2. Lock接口与AQS"></a>2. Lock接口与AQS</h3><ul>
<li><strong>ReentrantLock实现</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>AQS（AbstractQueuedSynchronizer）核心</strong>：<ul>
<li>维护一个CLH队列（FIFO）</li>
<li>通过CAS操作修改state字段</li>
<li>支持公平锁&#x2F;非公平锁</li>
</ul>
</li>
</ul>
<h3 id="3-并发工具类详解"><a href="#3-并发工具类详解" class="headerlink" title="3. 并发工具类详解"></a>3. 并发工具类详解</h3><table>
<thead>
<tr>
<th>类</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>CountDownLatch</code></td>
<td>计数器，等待多个线程完成</td>
<td><code>new CountDownLatch(3)</code></td>
</tr>
<tr>
<td><code>CyclicBarrier</code></td>
<td>循环屏障，等待固定数量线程</td>
<td><code>new CyclicBarrier(3)</code></td>
</tr>
<tr>
<td><code>Semaphore</code></td>
<td>信号量，控制并发数</td>
<td><code>new Semaphore(5)</code></td>
</tr>
<tr>
<td><code>Exchanger</code></td>
<td>线程间数据交换</td>
<td><code>exchanger.exchange(data)</code></td>
</tr>
<tr>
<td><code>Phaser</code></td>
<td>动态注册的屏障</td>
<td><code>phaser.register()</code></td>
</tr>
</tbody></table>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"># Java基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/12/30/ARL%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/" rel="prev" title="ARL食用指南">
                  <i class="fa fa-angle-left"></i> ARL食用指南
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZQ-Rookie-Hacker</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">145k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:04</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"ZQ-Rookie-Hacker/ZQ-Rookie-Hacker.github.io","issue_term":"pathname","theme":"preferred-color-scheme","label":"comment"}</script>
<script src="/js/third-party/comments/utterances.js" defer></script>

</body>
</html>
